<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>重新审视要做的事</title>
    <link href="undefined2020/01/02/reknowfrontend/"/>
    <url>2020/01/02/reknowfrontend/</url>
    
    <content type="html"><![CDATA[<p>之前写过好几篇关于要如何学习前端知识的文章，但是每过一段时间，总觉得要重新审视自己要学的内容，才能让自己不感到迷茫。</p><p>就目前就业的形势来看，非常不乐观，以我目前的水平，基本拿不到8k左右的前端工作，因此，一方面为了能够找到工作，另一方面为了提升自己的技术水平，我需要做一些针对性的规划，主要包括规范自己的学习内容、规范自己的学习方式、增加项目的实践、加强博客的撰写。</p><p>要达到能够就业的目标，需要能够吸引面试官的亮点，其一是“实践项目”，其二是“技术博客”，除了这两个亮点以外，还要能对面试过程中可能要问的问题有应答能力，也就是要对所学的技术掌握更加深入和透彻。</p><p>在简历中所写的技术点，也应当是自己真实想要掌握的或者已经掌握了的技术，这样才能展现出自己的技术针对性，也才可以在面试中回答出面试官的提问。</p><p>对于要学的内容，应当遵循“重基础，熟框架”的原则，要能够清晰准确地回答出各个技术能解决的问题，还要能够熟练使用框架进行开发（熟悉框架中的各种语法等）。</p><p>在简历中，我将写如下内容：<br>    － 熟练掌握html、css，熟练使用css3进行动画效果绘制，熟练使用canvas进行绘图。<br>    － 熟练掌握JavaScript，熟悉js异步编程，熟悉es6新特性。<br>    － 熟悉前端工程化开发，熟练使用webpack进行打包配置。<br>    － 熟练掌握requirejs进行前端模块化开发。<br>    － 熟练掌握vue、vue－router、vuex、axios进行webapp开发。<br>    － 熟练掌握jquery，能自定义开发jquery组件。<br>    － 熟练使用jqueryUI、bootstrap、elementUI等前端UI库进行快速开发。<br>    － 熟练掌握sass。<br>    － 熟练掌握git、svn工具进行团队协作开发。<br>    － 熟练掌握e2e进行模块单元测试。<br>    － 熟练掌握mockjs进行数据模拟。<br>    － 熟练掌握postman进行api测试。<br>    － 熟练使用ps进行图片处理。<br>    － 熟练使用mockplus进行原型制作。<br>    － 了解nodejs，会使用node的基础模块进行web开发。<br>    － 了解mysql，能使用sql语句对数据库进行增删改查。<br>    － 了解微信小程序开发，会使用微信开发者工具进行简单的小程序开发。<br>    － 了解linux环境，会进行基础的shell编程。<br>    － 了解java语言，了解ssm框架。</p><p>为了能让上述的内容能在简历中呈现出来，上述也是我要学习的内容，对于每一个学习的知识，都要进行总结，并在博客中发布出来。</p><p>上述内容的要求相对较高，为什么要把这些内容都列出来呢？因为这是我对将来技术学习的规划，要在3年内达到这个要求，这三年之中，无论当前的处境如何，都一定要在学习的路上，只要有上述知识的收获，就是当前再辛苦也是值得的。</p><p>另外，从项目的角度，我需要做以下的项目：<br>    － B站首页与播放页<br>    － 网易云课堂首页及内容页<br>    － QQ音乐自定义界面<br>    － 私密网页聊天（可做成uniapp）<br>    － 使用elementUI实现的后台管理系统<br>    － 使用cms实现的新闻站点<br>    － 小米商城全栈开发<br>    － 微信小程序商城</p><p>以上，为2019年11月1日对要学知识的重新审视，后续应当时刻回顾，记住自己要干什么。</p>]]></content>
    
    
    <categories>
      
      <category>frontend</category>
      
    </categories>
    
    
    <tags>
      
      <tag>规划</tag>
      
      <tag>反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.4聊天页面说明</title>
    <link href="undefined2019/11/04/11-4%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E8%AF%B4%E6%98%8E/"/>
    <url>2019/11/04/11-4%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="about-this-project"><a href="#about-this-project" class="headerlink" title="about this project"></a>about this project</h2><p>我要写一个聊天页面，包括前端和后端，这是开发的说明。</p><h2 id="at-the-beginning"><a href="#at-the-beginning" class="headerlink" title="at the beginning"></a>at the beginning</h2><p>这个项目的起因十分简单：想要学习nodejs，所以要有实践项目，而这就是一个比较简单易行的项目。所以，这是一个“从零基础”到“刚入门”的练手项目，过程中肯定会有很多很多不规范的地方，从项目目录到代码格式，到实现方法等。但我相信，经过这么一个“从零到一”的过程，我就能理解到nodejs项目中的很多优势和坑，积累很多经验。</p><p>为了把自己的脑子给调动起来，遇到的所有问题都先自己思考解决办法，而不是直接拿现成的框架，例如“自己写项目目录和服务器”而不是“用express框架”。当然，之后一定要重新去审视这些框架，最好重构一下自己的项目，这样能更深刻地理解框架的优点。虽然有点重复造轮子的赶脚，不过话说回来，我们写项目，不都是在造“更符合自身需求”的轮子吗？</p><h2 id="what-is-this"><a href="#what-is-this" class="headerlink" title="what is this?"></a>what is this?</h2><p>这是一个私密聊天工具，用于好友之间的私密聊天，服务器端不保存聊天信息，所有聊天信息只保存在客户端，若客户端的信息删除，则所有信息不可再得到，可以打开“阅后即焚”功能，使所有信息阅读后删除。有用户注册的功能，用户间可以添加好友，只有好友间能够互相发送消息。</p><p>第一版基于web，功能包含：</p><ul><li>用户注册</li><li>用户登录</li><li>添加好友</li><li>发送在线消息</li></ul><p>第二版或后续版本应当包含：</p><ul><li>基于小程序/hybrid</li><li>发送离线消息</li><li>发送图片等媒体资料</li><li>添加群组</li><li>群聊天</li><li>离线消息邮箱提示（微信提示？）</li></ul><h2 id="about-category"><a href="#about-category" class="headerlink" title="about category"></a>about category</h2><p><strong>api</strong>: 用于存放供客户端调用的功能模块<br><strong>doc</strong>: 项目的说明文档，api文档等<br><strong>router</strong>: 用于处理资源请求<br><strong>src</strong>: 存放前端资源，html/js/css/img等静态资源<br><strong>utils</strong>: 用于存放服务器端提炼的公共方法，例如处理路径、获取post数据等等<br><strong>index.js</strong>: 项目后端入口文件<br><strong>index.html</strong>: 项目的首页</p><p>其他都是一些共通的配置文件和模块文件，没有什么好说的。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>整个项目是一个前后端分离的项目。</p><p>前端采用jq最为dom操作的js库，使用基础的html+css进行排版布局，使用ajax与后端通信。</p><p>由于前端界面比较简单，若使用vue等框架则比较臃肿，因此直接采用jq+原生js进行dom操作，数据使用localStorage进行存储，不适用UI框架，而是自定义样式表，写一些基础组件。未采用webpack等模块化打包工具，也是因为项目简单，不使用es6/es7/scss/模块等内容。（因为就目前的规划来看，这个项目基本就是一个单页应用，组件的重复性使用可能性比较小，页面逻辑也比较简单，可以直接用js写在js文件里就行）</p><p>虽然这个项目的前端不采用工程化的开发方式，但工程化的开发确实应该尽快熟悉，尤其是“模块化”“组件化”“webpack打包（自动化）”确实应当要用起来，下一个项目预计就要使用了（“新闻网站”）。</p><p>后端采用node作为服务器，使用基础的url/fs/path/mysql/http等模块进行构建。使用mysql作为数据库进行数据的存储。使用socket.io创建socket连接，用于和客户端的双向通信。</p><p>后端跟前端最大的不一样，在于两个方面：逻辑严密+数据库操作。前端的重点可能在于页面布局和样式+交互逻辑，对于开发来说，逻辑可以不是特别严密，知识点本身也比较分散。而后端的每一步的逻辑都应当是非常紧密的，数据传递时的类型检验非常重要，不然很有可能因为数据格式的问题出错，如果没有单元测试，找bug可能就是一件非常痛苦的事情。</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>这是一个全栈项目，涉及项目开发的各个阶段，都是不大熟悉的内容，因此，对于每一个部分，都应当认真思考和总结，由其应当捋清楚各个部分之间的关系，尤其是一些基础库的使用，更应当仔细过一遍并熟练使用。</p>]]></content>
    
    
    <categories>
      
      <category>frontend</category>
      
      <category>backend</category>
      
      <category>program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>frontend</tag>
      
      <tag>backend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊天页面逻辑梳理</title>
    <link href="undefined2019/11/04/%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E9%80%BB%E8%BE%91%E6%A2%B3%E7%90%86/"/>
    <url>2019/11/04/%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E9%80%BB%E8%BE%91%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>前端工程师已经是大家不再陌生的一个软件行业的工种了，尽管这一工种诞生也没多少年。作为一名从业四年的前端工程师，我尝试结合业界标准与我的理解，来尽可能诠释一下前端工程师这个职业。<br>这篇文章的适读人群：非web方向的软件开发者、产品经理以及与产品挂钩的相关人士、正在纠结需不需要招聘一个前端的老板们、刚刚走上工作岗位的前端新手们、以及计划学习前端的从业人员。</p><p>前端工程师的英文名为front-end engineer，简称FE，下文将用FE来代称。<br>现在意义上的前端（并非只制作网页），国内最早开始有大规模招聘岗位应该是2011年左右的事情吧，在此之前，FE的工作基本都是由服务端工程师包办的，或者是由设计师来产出HTML页面。<br>那么，是什么样的原因催生出了FE这一职位呢？<br>这里将从FE的工作内容、专业FE应具备的技能和品质来聊聊这个职业。<br>用户体验的操刀者<br>前端工程师的首要工作就是开发用户界面，在web系统中，就是指网页了。<br>为什么网页需要专门的FE来写呢？答案就是「用户体验」。<br>随着web2.0概念的普及以及web3.0的提出，用户成为互联网的主要生产者，网页所承载的功能越来越多。<br>一方面，企业的「用户体验」诉求很强烈。这个很容易就能理解，如果你的产品看上去就像个钓鱼网站而且还特别难用，就会有一部分用户离你而去。非互联网企业呢？也会面临这样的情况，你花了很大的功夫优化数据库，优化服务器负载，你的客户却很难感知到你的努力。<br>你的系统界面还是八九十年代的风格，客户的第一感觉就是这系统不行，不买你的帐。相反，如果你花一点时间做一套崭新风格的界面出来，客户的第一感觉就是这个系统好炫酷，技术含量很高。不要小看这个第一感觉，对于外行人来说，第一感觉往往起到了决定作用。好多企业都意识到了这一点，所以对用户体验的诉求就上去了。<br>另一方面，现在的用户也都很挑剔。毕竟他们使用的产品一个比一个炫，都被惯坏了，你的产品稍有点不爽的地方，就上微博去给你宣传。<br>前端工程师是用户体验的把控者，在产品经理构想出交互原型，设计师设计出交互细节后，FE就用他的双手一行行敲出这些代码。他敲出的每一个按钮，每一张图片，都被成千上万的用户点击着，FE与用户可以说是“零距离接触”。作为产品交互的实现者，除了HTML、CSS这两门语言要精通外，对前端要求更高的其实是非技术因素。<br>FE需要对用户体验有较深的理解。比如页面上有一个超链接，字体比较小的情况下，用户可能会一下点不中，因为链接的可点击区域是紧贴着文字边缘的。前端可以通过很简单的方法来扩大这个链接的可点击区域，使得用户更容易点中。这就是用户体验，正如《瞬间之美》中提到的那样，touch到用户的内心只需要一瞬间。对用户体验的理解，还体现在对一些交互常识的把握上。比如用户操作某个软件的界面，会感觉它很灵巧，却具体说不出到底是哪里。那么很可能是这个界面上的按钮有着设计良好的四态（正常、鼠标移上、鼠标按下、不可用），它会随时对你的操作给出反馈。<br>懂用户体验的前端工程师，会让他的作品与用户沟通，能够touch到用户心中那一块柔软的区域。<br>FE需要有一点强迫症。这体现在对任何瑕疵的不容忍。比如采用技术手段让页面的滚动更平滑些，减少页面的视觉抖动，像素级别的定位校准。当用户触碰的内容是一串非电话号码的数字时，不要让手机自动调出拨号功能，等等。很多细节是产品经理无法感知的，因为这些都是很零散的技术手段，只有靠FE来点滴积累。再有极致者，追求让页面的响应时间再减少几个毫秒，让你的手机少耗几KB流量，少耗一些电量。这些甚至连用户都无法感知，但是当你的用户有百万级别或者千万级别，这样做的价值就显现出来了。<br>前端工程师需要是一个心思细腻之人，需要对美有所领悟，需要执着地追求完美，需要有品味，有思想，有大局观，最好还能懂点心理学。<br>用户端业务逻辑<br>做出优雅的界面只是前端工程师的第一步，编程也是必备技能，FE承担着处理用户端业务逻辑的任务。放在以前，用户端就是个IE浏览器，没有什么业务逻辑可言。但现在不同了，用户使用浏览器发表文章、进行社交活动，更复杂的能使用在线工具完成工作。<br>javascript就是FE需要掌握的编程语言，他应该通晓这门语言的优势和缺点，掌握各种编程思想、开发模式。利用各种技巧实现交互越来越丰富的界面，同时还要与服务端的工程师沟通，调试接口，完成：页面展示——响应用户操作——提交用户数据——反馈操作结果这一系列流程。<br>从这一点上，要求前端工程师要有软件开发的基础，了解计算机的基本原理，网络通信的基本原理，所以计算机相关专业出身的前端会更有优势一些。<br>写写网页也要架构？有什么好架的？回答这个问题首先得明确一点，FE的工作内容已不再是「写写页面」这么简单。随着前端代码的规模越来越大，逐渐涌现出了模块化开发、MVC、MVVM等开发模式。团队规模也从原来的单兵作战演变为团队开发。<br>所以，一个高级前端工程师，要有架构能力。这个架构能力包括不限于：<br>○对现有优秀框架的了解与整合使用<br>○根据项目的业务特点构建出合适的开发模式<br>○设计前端测试方案保证代码质量<br>○用工程化方案组织起团队的开发流程。<br>向前延伸、向后延伸<br>物联网的市场越来越热了，手机是物联网体系中的一个关键节点。前端工程师的战场已不再是单纯的浏览器，将来会覆盖到各种「端设备」上。得益于javascript语言的灵活性，现在用javascript已经可以开发windows应用、ios应用、android应用，可以编写智能电视上的应用。将来，或许是VR、可穿戴设备、智能家电。这是前端可以向前延伸的方向。<br>另一方面，由于nodejs的横空出世，javascript这门语言竟然神奇的有了服务端的能力。之前用java、PHP做的事情，js同样可以实现了。本来前端阵营中就有一批人是从后端转过来的，有服务端开发的基础，得了nodejs这一利器，再加上现在市场的需求，快出产品，敏捷开发，前端工程师向后延伸的路线宽广而明亮。事实上，全栈工程师的概念在前年就被提出，BAT这样的业界领头羊早已用nodejs做一些基础设施的建设，而很多小而快的创业公司，也在用nodejs进行快速迭代开发。<br>持续学习<br>前端领域的技术更新相对于其他领域要快很多，原因大概也是因为这个领域离用户最近吧。<br>有一些新的技术甚至是颠覆性的，前端工程师必须要跟上时代的步伐，否则你开发出的产品在体验上就落后别人一截了。<br>有一些市场人员提出的需求，产品经理根据多年的经验评估后觉得无法实现，就被打回了。<br>而事实上，随着新技术的出现，有些你认为无法实现的功能已经可以在前端实现了。<br>随着HTML5的支持度越来越高，前端拥有的能力也会越强。比如利用canvas能够获取到图片上的每一个像素点，这样前端就拥有了图像处理能力。<br>有了FileReader API，前端拥有了本地文件的读取能力，还有地理位置获取等等。<br>而这些新东西，就需要前端工程师来不断学习。所以，一个称职的前端必须能够保持持续学习能力，能够对新技术有敏锐的嗅觉。活到老，学到老，说的就是前端工程师。<br>高情商的程序猿<br>大多数人对程序猿的印象就是情商低、不善言谈。但前端工程师应该是个例外，这是由工作性质决定的。<br>从工作流程来看，FE处于设计师的下游，他要接设计稿，转化为网页。同时又是后端工程师的上游，需要把用户产生的数据提交到服务端。横向来看，他又与产品经理有着密切接触，因为他可能随时和产品经理探讨交互的细节。这样一个连接着团队中的其他成员的角色，需要他既是一个粘合剂，又是一个润滑剂。<br>前端工程师需要有较高的沟通能力和理解能力。我们经常开玩笑说“设计师活在童话故事里”，因为有时候他们设计的页面根本不符合常规，无法实现。这个时候你就需要耐心的给设计MM讲原理、讲原因，并且告诉她设计需要遵循哪些基本规范。对于产品经理的思想，你要能把握到位，你得理解他比划了半天到底是想要做什么。与后端工程师打交道的时候，你又得马上化身编程达人，跟他们聊数据类型，聊面向对象，聊设计模式。<br>你需要能随时切换角色，切换你的表达方式和谈话内容。所以，你得是一只高情商的程序员。<br>以上就是我对前端工程师的理解，前端的门槛低，但要成为一名专业的前端工程师，需要掌握的东西太多了。除了前端技术外，我认为前端更重要的是综合能力，包括我上面谈到的思维细腻、有品味、有思想、情商高等等。毕竟你要通过代码与用户产生接触，给用户带来愉悦感。<br>从某种程度上来说，你得是一个好恋人。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>h5新特性总结</title>
    <link href="undefined2019/11/02/h5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <url>2019/11/02/h5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="h5新特性总概括"><a href="#h5新特性总概括" class="headerlink" title="h5新特性总概括"></a>h5新特性总概括</h2><p>h5是新一代的html标准，相对于之前的html4.01而言，增加了很多的新特性，在html的基础上，熟悉h5的新特性，也就能更好地掌握前端开发中的三大支柱之一。</p><p>h5的新特性主要涉及以下几个方面：</p><ul><li>vedio/audio媒体属性</li><li>新增多个表单属性：input[type=”xxx”]</li><li>新增20多个新标签，主要应用于语义化，例如header、footer、aside、article、section、nav等</li><li>加强存储，localStorage和sessionStorage</li><li>新增绘图标签canvas,SVG</li><li>新增事件：drag和drop等</li><li>新增多线程处理worker</li></ul><p>新增的内容主要涵盖以下方面：表单增强、媒体增强、存储增强、画图增强、语义化、多线程。我无法全部都完全掌握，因此对于前面5个内容，我需要掌握，对于后两个（drag、worker），我只能先了解其大意，以后需要使用时再回头学习细节。</p><h2 id="vedio-audio媒体属性"><a href="#vedio-audio媒体属性" class="headerlink" title="vedio/audio媒体属性"></a>vedio/audio媒体属性</h2><p>这个是h5非常非常重要的特性，由于以前的网页是仅有文字和图片的，而视频的播放要靠flash等，兼容性不是很好，因此就在h5中增加了对视频和音频的支持，这也就丰富了网页的媒体形式。</p><p>对于一个vedio来说，我们会关心的事情有：</p><ul><li>视频的源文件在哪里? =&gt; src <code>&lt;source src&gt;</code></li><li>视频的格式是怎样的? =&gt; type = xxx</li><li>视频是否有控制台? =&gt; controls </li><li>视频是否能自动播放? =&gt; autoplay</li><li>视频是否能循环播放? =&gt; loop</li><li>视频能否播放声音还是静音? =&gt; muted</li><li>视频的播放大小有多大? =&gt; width height</li><li>视频格式不支持怎么办? =&gt; source source “your browser xxx”</li><li>视频第一张图片是什么? poster = “xxx”</li><li>视频听不懂是否有字幕? <code>&lt;track type=&quot;subtitle?&quot; src=&quot;./xxx.vtt&quot;&gt;</code></li></ul><p>对于一个音频来说，我们关心的事和视频相比，没有width/height和poster。</p><p>从网页能承载的媒体类型来看，其实这是媒体类型的一次改变，一个网页能承载的媒体有哪些？</p><ul><li>文字 =&gt; html</li><li>图片 =&gt; img</li><li>另一个页面 =&gt; iframe[src=””,sandbox,width=””,height=””]</li><li>视频 =&gt; video</li><li>音频 =&gt; audio</li><li>文档（pdf/txt/…) =&gt; object</li></ul><h2 id="画图增强"><a href="#画图增强" class="headerlink" title="画图增强"></a>画图增强</h2><p>从上一小节的媒体增强顺延下来，就是另一个媒体类型：图像。一般我们使用img标签来嵌入图片，在一些浏览器中，我们还可以使用img[srcset＝“xxx”]来使用媒体查询匹配大小更适配的图片。但这些都是普通的二进制图片，在存储中，需要存储图像每一个点的信息，若是一定大小的图片被放大，则会出现不清晰的情况。而解决这一问题的就是’位图’，在html中，可以使用SVG来绘制二维矢量图。</p><p>SVG是基于xml的，其本身有着一系列的画图的标签，可以使用这些标签来绘制图形，例如<code>&lt;rect x=&quot;&quot; y=&quot;&quot; strack=&quot;&quot; strack-width=&quot;&quot; fill=&quot;&quot;&gt;</code>就可以绘制一个方框。SVG的好处是基于xml也就可以被js调用api来控制，坏处是如果图形过于复杂则其本身就非常复杂，渲染也会非常消耗计算能力。SVG在制作面板数据时比较好用，可以很方便地绘制出基于数据的统计图。</p><p>图形中新增的还有一个canvas，这是一个基于js绘制图形的标签，优点是方便重绘，缺点是文字能力不强。</p><p>具体这两者有什么优劣，光是从网上看的资料并没有太多感受，但是这两者都可以应用于数据可视化，而非常出名的两个数据可视化的库echarts和d3就分别给予这两个标签封装的api，具体有什么差别，等用多了再看把。</p><h2 id="表单增强"><a href="#表单增强" class="headerlink" title="表单增强"></a>表单增强</h2><p>对于一个网页而言，除了要达到最基础的展示信息的作用（各种媒体），还要能够收集用户传回的数据，而收集的数据方式，也就是使用表单元素来进行收集了。在h5中对表单的增强也是非常重要的部分。</p><p>表单元素可以分为两个部分，一个是表单类型，一个是表单属性。表单类型中，增加了input[type＝“email/number/url/date…”]，也就意味着可以直接使用type来控制用户的输入检查。表单属性中，增加了autoFocus/autoComplete/placeHolder/required等。</p><h2 id="数据存储增强"><a href="#数据存储增强" class="headerlink" title="数据存储增强"></a>数据存储增强</h2><p>承接上一部分－表单，有了表单也就有了数据，数据的存储对于网页而言是很重要部分，以前网站的存储可以使用cookie，现在新增了sessionStorage和localStorage两种存储方式。</p><p>cookie，是一个最大为4k的字符串，主要用来存储用户的一些非关键信息，例如简单的喜好等。cookie可以设置失效时间，而且默认会跟着http的每一个请求头发送给服务器，因此用来存放sessionid是比较好的解决“检查是否登录“的方案。</p><p>sessionStorage，大小大致为5M(来自网络),存在的时间就是网页打开的时间，当网页关闭，则数据消失，可以用来存储一些用户配置信息等。</p><p>localStorage，大小大致为5M，除非主动删除，否则一直存在。可以用来存储一些基础数据（网页前置？）</p><p>这三者的使用方面，cookie的调用和处理最不方便，因为其本质就是一个常常的字符串，需要开发者自己通过字符串截取等操作来获取需要的信息。sessionStorage和localStorage有相应的api，相对来说使用更方便，例如xx.setItem=xxx。</p><h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>h5新增了很多的标签，但这些标签并没有功能上的用处，仅仅是标签名称的不同而已。例如：header、footer、nav、aside、article、section、configure等等。</p><p>语义化的作用有好一些：</p><ul><li>让文档结构更加清晰</li><li>对爬虫更加友好</li><li>阅读障碍人群友好</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上为对h5新特性的总结，后续还应当对css3进行总结。从实践的角度，应当对cookie存储登录信息进行使用，在项目中，用于登录验证。</p>]]></content>
    
    
    <categories>
      
      <category>frontend</category>
      
      <category>program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frontend</tag>
      
      <tag>js</tag>
      
      <tag>html</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo使用记录</title>
    <link href="undefined2019/11/02/hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>2019/11/02/hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>写博客对于学习it知识来说，是非常有必要的，一方面可以帮助自己梳理和巩固所学知识（由于it知识面广，知识点杂，不梳理的话，遗忘的速度太快），另一方面，这也是it人互帮互助的一种方式（知识分享的精神），因此，写博客，成了一项必备的能力。</p><p>那么，与写博客相对应的，就是拥有一套好用的博客系统，用于管理博客。最基础的博客，就是采用一些大平台的博客系统，例如“博客园”“天涯博客”“新浪博客”等等，在IT领域，还有“CSDN”“电子发烧友”这类平台，但这些博客系统的样式十分固定，没法根据自己的喜好进行调整（主题单一，没有个性）（虽然类似于“博客园”这种可以在一定程度上修改博客样式，但能修改内容非常有限），对于追求“极致”与“个性”的IT从业者们而言，这显然是满足不了需求的，因此，程序员们基本都会采用自己搭建博客系统的方式来写博客。</p><p>博客系统，说到底，其实就是一个CMS，可以把所写的文章，按照一定的流程进行处理，并形成一个完整的站点，因此，大多数CMS都是可以胜任“博客系统”这个角色的，例如“织梦”“帝国”“wordpress”等等。但实际上，由于开源性以及生态圈的活跃性等原因，wordpress作为个人博客的管理系统最为常见，wordpress有很多开源的主题，可供大家使用，搭建起来比较简单，也可以根据自己的喜好进行局部调整（二次开发）。</p><p>但wordpress本身也有很多的问题，例如运行速度慢，占用服务器内存较大等等，这是一个系统逐渐变得庞大不可避免的一个趋势，即使优化已经做到很好了，还是无法解决这个问题。（虽然这对我们这种小用户来说并没有太大影响）。因此，对于只想用来搭建博客系统的用户而言，一个“简洁”“快速”的博客系统会更加受到青睐，而Hexo就是这样一套系统。</p><p>hexo采用的是js开发，运行在node上，（这对于前端开发者而言，就更加亲切了），系统搭建过程和后期维护过程都十分简单，搭建时，只需要<code>npm install hexo-cli -g</code>就可以安装hexo的命令行工具，再使用<code>hexo init [blogsitename] &amp;&amp; npm i</code>就可以新建一个博客站点。使用<code>hexo s/server -p xxx</code>就可以创建一个监听xxx端口的http服务器，然后就可以访问了。</p><p>若想写博客，可以使用<code>hexo new post xxx</code>创建一个有基础信息的md文件，然后编辑这个文件写内容就ok。写完内容，要把博客发表出去，就使用<code>hexo g/generate</code>生成静态网页。若是想把本地的博客内容放到代码托管平台上（github），就可以使用<code>hexo d/deploy</code>来提交页面。</p><p>hexo还有一个非常重要的特性——改变主题非常方便，只需要找到一个中意的主题，在github上clone下来，直接放在themes文件夹内，并在_comfig.yml文件中把theme的值改一下，就可以使用新的主题了。而且网上有很多非常好看的主题，可以在hexo官网themes推荐里面去找一下。</p><p>另外，一个博客系统，最好能够不限制地方就能写博客，如果能直接提供web端的编辑器，就可以远程写博客了，那么，可以使用http://[ip]:[port]/admin的方式使用在线编辑器。</p><p>上述都是hexo最基础的搭建和发布的方式，而hexo经过了3代的更新，还有非常多其他的功能，例如引用图片、引用文字、引用数据等，再例如模板文件等等，都有其相应的使用场景，具体内容，可以直接看hexo的官方文档，写的还是很清楚的。</p><p>那么，对于我而言，当前能使用最基础的md写简单的博客就已经能满足需求了。最重要的，是要经常写博客，把所学的知识用自己的语言重新组织一次，才能融汇贯通啊。</p>]]></content>
    
    
    <categories>
      
      <category>frontend</category>
      
      <category>program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某webpack脚手架使用</title>
    <link href="undefined2019/10/11/%E5%90%91%E7%89%A9+%E5%BC%80%E7%AE%B1webpack%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <url>2019/10/11/%E5%90%91%E7%89%A9+%E5%BC%80%E7%AE%B1webpack%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="学习说明"><a href="#学习说明" class="headerlink" title="学习说明"></a>学习说明</h2><p>之前在寻找web页面用于模仿时，找到了“向物”这个网站，当初没有细看，只觉得这个网站比较清新，就定了要模仿的计划，但在模仿开始才发现，这个网站是一个“几乎全用图片堆砌而成”的网站，那么调整规划，把这个网站当成一次静态网站的webpack脚手架使用来模仿。</p><p>之前一直使用的都是vue-cli的webpack脚手架，虽然知道webpack在模块化开发后用于打包十分厉害，但是一直没有仔细地研究webpack的各项配置，遵循循序渐进的原则，我先使用一下其他的webpack脚手架。</p><p>这个webpack脚手架来源于github上的开源项目，名为“multipage-webpack-scaffolding”，目的很明确，用于开发多页面，可以通过简单的两步，就可以直接打包了。模块化开发的优势自然是非常明显的，可以使用import/require等添加各种依赖，那么很多复杂的功能就不再需要人工手动去添加了，而且还保持了源码的干净整洁，跟之前的在一个大html文件中写各种代码相比，方便了不知多少。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建站与我所学知识的价值</title>
    <link href="undefined2019/10/10/%E5%BB%BA%E7%AB%99%E4%B8%8E%E6%88%91%E6%89%80%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
    <url>2019/10/10/%E5%BB%BA%E7%AB%99%E4%B8%8E%E6%88%91%E6%89%80%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%9A%84%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="内容说明"><a href="#内容说明" class="headerlink" title="内容说明"></a>内容说明</h2><ul><li>从最开始学习计算机相关知识起，就是从web前端知识开始的，当初并不知道自己所学的东西在计算机技术方面属于什么方向，回顾自己的学习历程，详见<a href="#learned">点击这里</a>，在此基础上找到自己的兴趣点，<a href="#tolearn">点击这里</a>。</li></ul><h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><ul><li>之前一直在学习基础的html、css的知识，知道自己的最初目标是实现基础的网页制作，想要模仿几个网站，想要写一个自己的博客系统，当时并不知道这意味着什么。但是现在来看，我学习这些技术，当前的最终目的，就是完成一个web系统，这个web系统可能属于不同的行业，属于不同的目的，因此他们有很多不同的特征，但是作为一个IT系统，他们都有一个公共的特征，都是把“内容”展示给用户，并接受用户的反馈，再根据用户的反馈做出响应。换句话说，我们做的都是“内容管理”。</li><li>那么，内容的特征可以分为很多种，最最最基础也是最最最重要的就是静态网页，因为静态网页可以完成一个web系统几乎一半的作用–“展示内容”，而后的动态网站就可以在静态网站上添加功能模块实现（例如登录系统、评论系统、支付系统、发布系统等），虽然大型网站基本都是动态网站，但是，对于大多数企业而言，静态网站就足以达到其目标。</li><li>所谓的动态网站，其实是在静态网站的基础上，增加了与后台的数据交互，进而改变静态网站上部分元素的过程，这部分工作在前端是由js完成的，因此，完全可以采用以静态网站的内容管理系统进行管理，同时使用js控制数据交互。</li><li>这里的静态网站的内容管理系统，通俗来说，就是能够使我们的网站进行自动化发布的一套程序，可以是企业自行开发的系统（例如大型互联网企业都是自己的系统），也可以使用开源的内容管理系统，例如织梦CMS、帝国CMS、pageadmin、wordpress、discuzz等等，这些cms的一大优势就在于模板丰富，对于那些中小企业而言，想搭建一个企业门户网站、论坛、产品展示等页面还是非常方便的，只需要拿着模板，改一下内容，整个网站就算搞定了。</li><li>虽然之前有些看不上仿站这类工作，但实际上这些需求才是最多的，拿个网站模板一改，就是一个还算不错的网站。对于大多数小企业而言，这是一件非常有效率的事。因此，我必须要会使用其中一种用于快速搭建网站。</li><li>上述这些开源的cms，大多是php+mysql的后台。</li><li>博客系统其本质也是一个cms，因此有很多使用pageadmin、wordpress搭建博客系统，在node环境下也有相同的系统，例如hexo，若把博客系统看作是门户网站，博客内容看作是产品信息，其实也可以直接把hexo作为建站工具吧？</li></ul><h2 id="我的尝试"><a href="#我的尝试" class="headerlink" title="我的尝试"></a>我的尝试</h2><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="我所学的知识是什么？"><a href="#我所学的知识是什么？" class="headerlink" title="我所学的知识是什么？"></a><span id="learned">我所学的知识是什么？</span></h3><p>我最开始接触到计算机编程知识的途径是W3Cschool这种编程自学网站，从最初的html、css开始学习，在熟悉了部分标签和样式之后，继续学习了一些js知识，接触了jq和vue，样式库方面接触了bootstrap，了解了一些非常常见的库，例如animate、swiper等，之后就本着“从实践中学习”的理念，开始了仿写第一个网站–bilibili首页，随后为了增加网站的丰富度，又写了视频播放页面，在这个过程中增加了对html和css的部分熟练度，同时增加了对jq的熟练度。而后为了适应移动端页面，又手写了移动端的几个页面，并使用node环境写了一个服务端server.js，实现了简单的区分客户端设备类型返回不同页面的功能。自此，第一个练手项目算是完成。总结一些这段初始的经历，算是基本入门了，能够使用html和css以及jq写出逻辑比较简单的页面，能够完成一些基础的动作。不足之处在于，对html的深入理解还不够，未能理解到html的设计思想以及其渲染方式等；css方面，对于一些常见模型的总结不足，例如布局方式的总结，动画实现的总结等；jq方面，虽然能够使用简单的api选取元素以及操作元素，但对于jq插件、jq组件这些稍微深层次的内容几乎为空白，更不用说对jq的源码和设计模式的学习了；js方面，这方面尤其值得一提，目前应用最广泛的ES5，以及逐步增长的ES6与ES7，知识的变化速度非常快，而我对js的理解几乎停留在对基础语法上，对于较高级的用法几乎为空白，例如promise，constructor，await等。这些都是我需要弥补的地方。</p><p>在这之后，我开始接触到服务器，租了腾讯的vps和阿里的vps（均为windows系统），而后又租了海外vps（linux系统），在windows服务器上搭建了svn服务、IIS服务、FTP服务、wireshark，在linux上搭建了ss服务、apache服务，在进行了一些基础的操作后，对linux服务器有了基础的认识，开始关注到树莓派，并入手了一块树莓派3B，玩了一些小的项目，例如在树莓派上搭建各类服务器，使用ssh转发端口到云服务器，使用树莓派做远程视频，使用树莓派的GPIO控制电机、接收信号等等。这个过程中还玩了小米路由器和arduino，买了一堆零件做了个简单的智能小车。</p><p>技术能玩的东西特别多，只要进入了这个世界，保持持续的兴趣几乎是不需要担心的事。但我学习IT技术，同样也为了能够以此为养活自己的手段，因此，学习不能完全由着自己的性子来，同样要兼顾工作的需要来规划学习内容。于是，我开始了对vue的学习，并抱着“从实践中学习”的理念，动手了第二个项目–网易云课堂vue模仿。同时，以此为契机，再一次熟悉了node环境下模块化编程的流程。</p><p>目前而言，我学习web前端也有很长一段时间了，但是几乎一直都是在迷茫中度过的，不知道自己的水平如何，不知道自己所学的东西是否能在工作中发挥较大效用，也一直没有勇气投出自己的简历参加面试。我知道，如果不去尝试改变，这样的状态是几乎不会有太多改善的，“闭门造车”的方式在技术学习上是行不通的。应当从这样的状态走出去，去看看社会中真正需要的是什么样的能力，去看看自己处于什么样的水平。大不了就是认识到自己的不足，从最底层的工作开始做。只要记住，永远保持探索和拼搏的精神，勇敢地认识真实的自己，你的生活就不会太无聊。</p><p>最后送给自己一句话：别害怕，从开始害怕的那一刻起，就注定无法成事。</p><h3 id="我要做什么？"><a href="#我要做什么？" class="headerlink" title="我要做什么？"></a><span id="tolearn">我要做什么？</span></h3><p>IT技术能划分的方向特别多，能划分的标准也特别多，我这里的划分方法采取交叉的划分方法。<br>从开发流程中的职位来看，产品、UI、前端、后端、运维，我应当是从前端入门，然后转向后端，实现全栈开发。<br>从编程语言上来说，php、js、java、python…，我应当是以js为基础，然后继续学习java，并了解php和python。<br>从客户端上来看，PCweb、mobileWeb、hybrid、小程序、native，我应当是先以pcweb、mobileWeb为基础，逐渐学习hybrid、小程序、native。<br>从产品类型上来看，pc官网、商城、功能型网站、后台型页面、活动型页面、webapp页面、小程序页面…，我应当是先从展示性网站（pc官网、活动页面、商城的展示部分）向功能型页面（商城的功能模块、后台、其他功能如视频）转变。<br>从技术类型上来说，jq、vue、react、es5/6/7、node…，我应当先着重学习以jq和vue为基础的web前端基础知识，在熟练掌握html、css的基础后，深入学习js（es5/6/7），并在这个过程中熟练应用jq和vue，理解其部分原理。<br>从实践上来说，我要构建众多网站，同时以开源的vue项目为材料，分析他人源码（如网易云音乐vue版、知乎日报vue版）。要将自己学习的内容进行深度笔记式总结，并以博客的形式发表。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>在学习知识时，没有践行“打破砂锅问到底”的原则。一直以来，认为一个观点，抛开外在资源等不谈，人与人之间的不同，主要体现在“学习能力”上，而学习能力，重要的一点就是“打破砂锅问到底”的专研精神，从以往学习经验来看，这是使我受益匪浅的一种学习态度。但是几乎上从上大学开始，我的这种学习态度不复存在，以致于大学几年都没有真正学到结构化的、成体系的知识。</p><p>现在，我应当重拾这种精神，在自己想要学习的范围内，不放过一切的知识块与知识点，遇到了不明白的内容，就积累在学习规划上，及时找时间进行学习和弥补。</p><p>另外一个问题，我没有践行“将知识联系起来”的原则。知识只有成体系，才能称得上是自己掌握了的知识，今后的学习也都是在这个体系上拓展和深化，在学习一部分知识时，若连这块知识在自己知识体系中的位置都不清楚的话，那么终究摆脱不了被快速遗忘的命运。因此，在学习时，首先要弄清楚知识之间的关系，再进行学习，学习完之后再进行总结。同时，所学的材料，最好是自成体系的，具有比较完整的结构，才能增强新知识本身的结构化。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>站点开发思考与总结</title>
    <link href="undefined2019/09/21/%E7%AB%99%E7%82%B9%E5%BC%80%E5%8F%91%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>2019/09/21/%E7%AB%99%E7%82%B9%E5%BC%80%E5%8F%91%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><ul><li>今天的内容是①迅速搭建一个简单的页面(仿写页面sothing.net)，这是个有少许产品的官网，大部分介绍性内容采用图片拼合的方式，也没有太多的动画效果，写起来应该算是简单。写这个页面的原因，是觉得风格还算简洁（虽然大都体现在图片上）。</li><li>这个页面计划采用webpack作为打包工具，页面内采用自定义组件，自定义路由，最终做成一个单页应用。（这里是否做单页其实没有太大关系，单页的主要作用是后台进行数据交互，直接替换部分内容，而不用跳转，因此对小型的站点而言，完全可以直接写单页，作用也很明显，没有跳转过程，无需等待，若再加上路由滑动效果，则可以类似于native应用一般四化流畅。）</li><li>从这个项目开始，所有项目要实现比较精细化的过程控制，需要越来越严格地按照<code>商业化合作标准</code>+<code>学习化问题记录</code>这两个行为准则去写网页，还原到较真实的场景中去。</li></ul><h2 id="我的尝试"><a href="#我的尝试" class="headerlink" title="我的尝试"></a>我的尝试</h2><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><h3 id="关于网站的分类"><a href="#关于网站的分类" class="headerlink" title="关于网站的分类"></a>关于网站的分类</h3><ul><li><p>不同类型的网站特征差别较大，因此有必要对网站类型进行划分，便于从整体上认识网站开发的不同特点。网站的分类方式可以根据：主体类型、网站用途、网站功能、技术基础、网站载体、行业类型这几个维度。</p></li><li><p>在对网站需求分析时，需要在脑海中形成对该网站的大体认识，此时就可以从这些角度切入。</p></li><li><p>主体类型：虽然实际开发时决定开发的是需求，但不同主体类型的需求本身就是具有集中度的，例如政府网站、事业单位网站和商业企业网站相比，对<code>美观/灵活</code>的需求就比较少，而对<code>稳定/安全/简单</code>的需求就比较大。再说个人网站，<code>个性</code>的需求就非常明显。</p></li><li><p>网站用途：这个分类与<code>网站功能</code>分类有时候可能有含糊不清的时候，例如<code>企业论坛网站</code>，究竟是网站的用途还是功能？因此，在此区分一下，用途的类型确定为几个类，这几个类的特点比较突出，商业目的比较明确，而其他商业目的不突出的，则分为<code>功能性网站</code>。</p></li><li><p>网站功能：这个<code>功能</code>，指的是确确实实的<code>用户能做什么</code>，例如<code>播放视频</code>、<code>展示图表数据</code>、<code>玩小游戏</code>、<code>办公操作</code>、<code>评论交流</code>…。这部分内容划分颗粒度需要把控，否则容易陷入细节陷阱中，例如用<code>交流评论</code>来概括<code>发评论、发弹幕、点赞、分享、加好友</code>等等细节功能。因为从<code>对网站分类</code>的目的来说，是为了<code>把握网站特征</code>，而不是为了<code>开发时的模块划分</code>。</p></li><li><p>技术基础：当前，作为网站开发语言(平台)的主要有php、java、js、.NET、asp这些，当然也有python、go等语言为基础的后台框架，不同的后台基础对前端而言在数据交互上可能需要协调。</p></li><li><p>网站载体：这是指网站展示的主要设备，例如使用<code>PC端浏览器</code>、<code>移动端浏览器</code>、<code>移动端APP内嵌页面</code>、<code>小程序页面</code>，不同载体下网站的表现形式差别较大，需要考虑是否使用多端适配的框架。</p></li><li><p>主体所属行业：虽然可以通过主体类型进行划分，但其实，在商业网站中，不同行业对网站特征的影响十分大，例如<code>服装行业</code>和<code>科技行业</code>的官方网站差别就非常巨大，前者可能会追求<code>自然的美/简洁大方/华丽</code>，后者可能追求<code>炫酷/功能/极致</code>，再如<code>餐饮行业</code>和<code>汽车行业</code>所展示的内容差别也很大。</p></li><li><p>网站的类型有哪些</p><ul><li>根据主体性质，可以分为：政府网站、事业单位网站、商业企业网站、非盈利组织网站、个人网站。</li><li>根据网站用途，可以分为：官方网站、产品展示网站、商城购物型网站、门户型网站、功能性网站（详见下一点）</li><li>根据网站的功能，可以分为：图表文字展示型、视频播放型、H5游戏型、OA操作型(ERP/CRM/MIS/markdown)、用户互动型</li><li>根据网站的技术基础，可以分为：asp、asp.net、php、java、js等</li><li>根据网站载体，可以分为：移动端web、移动端native、微信小程序、pc端web、多平台兼容。</li><li>根据主体行业，可以分为：服装行业、餐饮行业、汽车行业、家装行业、酒店行业、教育行业、电商行业……</li></ul></li></ul><h3 id="关于网站的开发流程"><a href="#关于网站的开发流程" class="headerlink" title="关于网站的开发流程"></a>关于网站的开发流程</h3><ul><li><p>在做网站开发时，需要对项目规划非常明确，以达到时刻掌握项目进度的目的，因此就需要知道网站在开发过程中需要经过哪些阶段，最好还要知道这些阶段中的各个细节工作特点。</p></li><li><p>网站开发的流程</p><ul><li>确定需求(提供需求+需求评估+修改需求+确认需求)</li><li>设计原型(UI设计+原型展示)</li><li>编程实现功能(前端开发/后端开发+数据交互规范+文档编写)</li><li>上线前测试(本地测试+上线测试+修补代码)</li><li>项目上线(上线交付)</li><li>后期维护(使用文档维护+BUG处理+升级调试)</li></ul></li></ul><h3 id="关于网站整体规划文档"><a href="#关于网站整体规划文档" class="headerlink" title="关于网站整体规划文档"></a>关于网站整体规划文档</h3><ul><li>开发过程中，需要跟‘客户’沟通需求、沟通进度、沟通预算等，这是我们需要给对方阐述清楚我们对整个网站的规划框架，这时，我们最好写一份网站整体规划书，用于跟需求方进行前期沟通。（不同于产品需求书，这份规划书仅描述整体规划以及大致需求，不涉及太多细节上的需求）</li><li>网站整体规划书，应当要包括以下几个部分：<ul><li>公司简介（介绍公司名称、行业范围、发展历程、当前对网站的需求起因）</li><li>网站功能需求（介绍网站的功能，对公司而言有什么作用）</li><li>网站风格与整体布局（说明网站的UI风格，以及页面组成情况，各页面的布局情况）</li><li>板块说明（说明不同页面不同板块的主要内容与作用）</li><li>技术解决方案（简介该网站的前端和后端的技术方案）</li><li>预算及费用（根据规划的各细项，列明预算，例如策划、UI、原型、前端、后端、服务器、域名等）</li><li>项目进度与人员安排（划分项目不同阶段，列明每个阶段要做的事情，以及给不同的人分工，可以是简单的阶段划分任务划分以及人员分工，在实际执行项目时，需要使用项目管理方法进行管理，例如<code>项目计划及进度完成情况表/甘特图</code>等）</li></ul></li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站</tag>
      
      <tag>工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue学习记录+css复习</title>
    <link href="undefined2019/09/19/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+css%E5%A4%8D%E4%B9%A0/"/>
    <url>2019/09/19/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+css%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><ul><li>vue中，数据是单项传递的，也就是父组件可以将数据传递给自组件，且父组件数据改变，自组建会跟着改变，要想让自组件的值传递给父组件，可以使用至少两种方式，最简单的是给父组件添加自定义事件，并监听父组件中子组件标签的该事件，<code>&lt;childNode @myEvent=&quot;funName&quot;&gt;&lt;/childNode&gt;</code>，在子组件中使用<code>this.$emit(&#39;funName&#39;,data)</code>触发该事件，并传递值data。第二种在父组件中使用<code>:tdata.sync=&quot;tdata&quot;</code>，这是数据绑定修饰符（具体没有尝试，留作思路之一）。</li><li>vue中，由于computed属性原始只能是一个getter，无法传入参数，但有时候绑定的数据又需要根据一些参数进行确定，因此传递参数就非常必要，此时可以使用<code>function(){return (function(xxx){})}</code>的方式，使computed返回一个带参数输入的函数，进而接收传入的参数。</li></ul><h2 id="我的尝试"><a href="#我的尝试" class="headerlink" title="我的尝试"></a>我的尝试</h2><ul><li>把B站的站点做成完整站点，包括后台数据交互（使用php做后台）。<ul><li>前端使用ajax进行数据交互，把几个mode改成template的形式，template框架再选。</li></ul></li><li>把网易云课堂站点的三个页面全部写出来，并使用nodejs做后台实现部分数据交互。<strong>留了一点点，回头来搞</strong><ul><li>原计划把index、course、category三个页面都做出来，但是category页面真的是太水了，几乎全是cou组件组成的，没有太大的价值，暂时不做。</li><li>数据的话，用爬虫爬取部分数据吧，本来东西也不多。</li><li>nodejs+mysql作为后台web服务器和数据库。</li><li>趁这个机会，把SQL系统性复习一下。</li></ul></li><li>快速模仿3个站点（争取一天做到3个站点的元素）。<ul><li>向物（直接写组件，自己封装简单的组件加载器）</li><li>知乎首页 （用template来写，并使用路由做SPA，后台使用IIS+php的方式）</li><li>玩物志（使用template，做单页，注重对登录、添加购物车、打包订单的逻辑）</li><li>一条官网（使用vue+router+axios+vuex+node+mysql完美实现还原）{做移动端适配}</li><li>唯品会首页（使用jq+template，着重于组件的实现以及布局的准确）</li><li>网易云音乐（用vue+router+axios来写）（什么页面用vuex能体现价值？）（做native app适配）</li></ul></li></ul><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><ul><li>在用vue写页面的时候，发现与之前用jq或直接用js相比，在事件处理上以及对不常用的元素属性处理上不大方便。vue的事件处理采用的是<code>v-on:xxx=&quot;xxxx;xxxx;&quot;</code>这样的方式，也就是说，对元素绑定事件采用单个元素进行绑定，而对于一些通用的元素绑定时则不大方便，同时vue的数据绑定需要单独使用<code>v-bind:xx=&quot;xxx&quot;</code>的方式进行，而一个元素的属性十分繁杂，不可能把数据都绑定了，因此对于一些不常用的属性，在改变时还是不大方便。例如对非组件的小按钮（或a元素等），放上改变其背景/位置/颜色等，若是使用jq，可以直接使用<code>$(&quot;.xx&quot;).on(&quot;&quot;,fun)</code>，在回调函数中，直接使用<code>$(this).css({xxx})</code>就可以设置css，这种情况下，无论是绑定事件或是改变元素值，都不大方便。</li><li>看了一下他人的方法，都是采用在vue中使用钩子执行额外的js或jq（例如<code>mounted:{xxx}</code>），获取元素可采用vue的内部属性，也可以直接使用js或jq获取，例如<code>$event.target</code>或<code>$ref</code>，从js或jq则使用<code>document.querySelector(&#39;xx&#39;)</code>或<code>document.getElementsByClassname(&quot;xx&quot;)</code>或<code>$(&#39;.xxx&#39;)</code>。</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul><li><p>css布局疑难杂症：当父元素为absolute，子元素为多个float时，子元素无法撑开父元素的宽度达到横向布局的效果。使用纯css暂时无解，可使用js操作，或根据页面元素宽度，给一个固定的宽度。</p></li><li><p>布局的几种方式：</p><ul><li>table布局：可以使用table/tr/td然后在td内写内容，或直接使用<code>display: table/table-row/table-cell/table-column/table-row-group;</code>设置div的display。但由于table布局基本过时，选择放弃学习该部分。</li><li>position布局：可以设置position为<code>static/relative/absolute/fixed</code>，用于设置元素在文档中的位置。配合使用<code>top/left/right/bottom</code>以及<code>margin -xxx</code>进行布局。使用较多，也比较简单。</li><li>float布局：设置<code>float: left/right</code>，可使元素脱离文档流，但不脱离文件流，类似于word排版中的文字环绕。float布局最容易出现的问题是父元素高度塌陷，对父元素使用<code>overflow: hidden</code>或者对父元素添加伪类<code>xxx:after {content:&quot;&quot;;display:&quot;block&quot;;clear:&quot;both&quot;}</code>这两种方式解决该问题。（有可能出现父元素为absolute，子元素为多个float的情况，此时无法使用上述方法撑开父元素的宽度）。</li><li>flex布局：通过对父元素使用<code>display:flex/inline-flex;</code>达到对所有子元素进行布局的效果。可以使用<code>flex-direction/flex-wrap =&gt; flex-flow</code>设置元素排列顺序，使用<code>justify-content: flex-start/flex-end/center/space-between/space-around</code>设置元素水平的排列方式，使用<code>align-items: flex-start/flex-end/center/baseline/stretch</code>设置垂直方向的排列方式（align-content设置多行元素）。<a href="https://www.cnblogs.com/dreamperson/p/9367008.html" target="_blank" rel="noopener">flex布局参考</a></li><li>使用@media的响应式布局，使用<code>@media screen and (max-width: 748px) {xxx}</code>的方式进行布局。</li><li>使用一些UI框架进行布局，例如bootstrap/foundation/elementUI这类，虽然底层的实现方式也类似于@media这些，但是在使用过程中的API完全不同，因此也可以说是一种新的布局方式。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css知识复习需求</title>
    <link href="undefined2019/09/15/css%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E9%9C%80%E6%B1%82/"/>
    <url>2019/09/15/css%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="关于css（以及从css引发的复习需要）"><a href="#关于css（以及从css引发的复习需要）" class="headerlink" title="关于css（以及从css引发的复习需要）"></a>关于css（以及从css引发的复习需要）</h3><ul><li>css主要有两个作用：布局+样式。在之前的学习时，由于担心对IE兼容的问题，在布局方面大量采用定位的布局方式。但实际目前大多数的浏览器（主要限制为IE10（菜鸟教程写的11））都是支持弹性盒子布局的，因此需要补充对布局方式的学习和实践。</li><li>css布局：<ul><li>现在的网页环境，已经不仅仅是电脑端的web页面，移动端的页面其实已经非常重要，而我的关注度还远远不足。移动端的前端工作可以分为两个部分，其一是以浏览器为基础的移动端web前端，其二是以app为基础的移动端应用程序前端（或许可以把以微信为基础的小程序前端算成第2.5个）。作为从电脑端web开始学习的我来说，目前仅了解以html标签和基础的css样式做页面内容和样式的实现，这与移动端web前端所使用的标签和样式几乎一样，但也有各自的一些特色（移动端的页面更小，不需要的组件要隐藏，移动端有“触摸”这个动作，移动端的浏览器适配更重要），因此，最容易拓展的技术范围是向移动端web，这也是需要紧急做的事。</li><li>从布局上来说，要想做响应式的布局，方式大致有三种：float浮动布局、flex弹性布局、@media媒体查询（可@media与grid搭配）。这三种方式是直接由css提供的布局方式，在此基础上，一些第三方库做了一些封装，可使布局更加简单（使用class属性即可），例如最热的bootstrap，foundation等（还有很多，不过都不熟）。</li></ul></li><li><strong>学习内容需要</strong> 需要把css的知识和html的知识复习一次，并把之前落下的不熟的知识点补充起来，并做博客记录，目前能想到的要补充的知识：css布局（主要为flex，其次为@media），css动画（内容较多，如gradients、filter、animation、transform），css前缀积累，css疑难问题解决（查阅他人经验总结）、css hack；html媒体标签、SVG使用、深入理解html标签各属性的作用（例如contenteditable这类的实现原理）、html本地存储、表单校验实例、session与cookie/local存储以及免验证登录的方式；总结浏览器的js对象（navigator/history/dom/screen/location）、<s>常用</s>（<em>内建对象都很常用</em>）js内建对象（Math/String/Date/Object/Number/Array/RegExp）、prototype以及构造函数在对象构建和继承上的作用、promise、Generator、Iterator、symbol、Set/Map结构、Proxy、错误处理；web前端编程常用的工具：单元测试、ajax、加密模块。</li></ul><h3 id="css实践问题"><a href="#css实践问题" class="headerlink" title="css实践问题"></a>css实践问题</h3><ul><li>当父元素为absolute，子元素为float导致父元素高度塌陷，应该如何解决？</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>css</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue学习记录+node部分学习4</title>
    <link href="undefined2019/09/12/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A04/"/>
    <url>2019/09/12/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A04/</url>
    
    <content type="html"><![CDATA[<h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><h3 id="从前端工具具体内容看vue"><a href="#从前端工具具体内容看vue" class="headerlink" title="从前端工具具体内容看vue"></a>从前端工具具体内容看vue</h3><ul><li>用vue进行开发，很大的一个特点就是<code>组件化</code>，一个核心概念是<code>web应用是由各个组件组成的组件树</code>，因此组件开发是在vue开发过程中最常接触到的内容。要进行组件化开发，首先要做的就是对组件进行抽象，提取公共组件或者私有组件。组件的划分算是一个比较技术性的工作，要如何划分组件才能使组件的复用性和可维护性更高。</li><li>组件划分的方式：<ul><li>功能化组件划分</li><li>区域化组件划分</li><li>待续…</li></ul></li><li>组件划分的细度是一个摆在眼前的问题，组件的作用在于可以一次维护，避免了以往的不同位置的相似部分需要单独维护的麻烦，那么组件究竟要拆到多细呢？我觉得从可维护性和复用性的角度出发，会重复使用的组件需要单独拆分，具有明显内容或功能差别的部分需要单独拆分。举个例子，header，main，footer，nav，sidebar这些就属于具有明显内容差别的部分，再如<code>卡片</code>就是会重复使用的部分。</li><li>没有vue这种MVVM框架之前，前端的工作主要是<code>view</code>，因此最常见的站点形式是一堆的html文件，使用<code>a</code>标签进行页面间的跳转，因此基本不需要太多的js逻辑实现，前端需要会的就是html标签和css样式以及非常基础的基于浏览器对象的js。工作的目的是编写出不同的html模板，再用css调整样式，为了给元素增加一些动作，会使用js操作DOM进行样式变换。而数据产生的逻辑关系大部分由后端完成。web应用是基于<code>模板引擎</code>这种东西实现数据逻辑的，因此php和jsp在后端大放光彩（asp.net也算），数据处理、路由分发等等都是由他们实现的。</li><li>那时的前端工作着眼于<code>内容</code>和<code>效果</code>以及简单的<code>动作</code>，因此跟后端奇怪的数据交互相比，会简单一些。要掌握的工具也比较简单，如html标签；css样式的特点和兼容；<code>js库jquery、zepto、prototype</code>这类着眼于dom操作的库（当然也封装了ajax等非dom操作的函数）；UI库<code>bootstrap、layUI、foundation、jqueryUI、ZUI</code>（当然除了大量的UI组件外，也提供了部分js封装的函数用于插件的运行）；一些常用插件（说库也行），例如<code>datePicker，silder，fontawesome，animate，Echarts</code>等。以上，基本就可以上手工作了。</li><li>当然，前端肯定不仅仅是写一下页面和效果（当然也要看web应用的用处），以前门户网站和展示性网站这类最基础的网站，做的最多的自然是设计布局、填充内容、设计动画这些，很少有跟后端的数据交互，这类网站只要有一个合适的模板，直接套上去改改内容，再加一个CMS基本就可以搞定。但是现在的web应用，都是跟用户之间有着不间断的交互，因此跟后端的交互非常频繁，有了数据交互，前端就要进行数据处理并根据数据执行一些动作，那么这时仅仅是会上面说的那些就显得不足了。这时对于js的掌握程度就显得尤为重要了，所有的动作都是基于js实现的（虽然可能使用一些的库），编写js函数就是重中之重了，因此，学好js尤为重要。</li><li>当nodejs逐渐成熟之后，前端工程师的范围又得到了扩展，可以进入到后端的编程中去。从以前的前后端划分标准来看，前端主要负责客户端的展示和部分逻辑数据处理，后端主要负责业务逻辑处理和数据存储。但从编程的实质来看，若将前端的逻辑数据处理的作用稍稍放大，其实跟后端来处理业务逻辑之间有着部分的可替代性。‘把数据直接交给前端处理’和‘把数据在后端处理好了再交给前端’这两件事情本身就是一个可以相互让步的，因此增强前端的能力，弱化后端部分能力，在模式上是完全行得通的。‘是否这样做’是一个值得思考的问题，需要根据实际项目而定。</li><li>既然js也可以用于后端程序处理，那么在一定程度上，js的使用范围就扩大了，从前端到后端，都可以使用js完成，于是前端工程师们很自然而然的，就会以‘增强自身竞争力’为由学习node。说是学习node，实质是学习常用于后端的一些包，例如<code>http、fs、url、path、express、koa、mysql</code>等，这些包本身是用js封装的一些有特定作用的函数库，调用这些函数就可以进行后端常见的操作，例如读写文件、读取数据库数据、发起http请求或响应请求等。</li><li>到了这一步，基本就可以通过js从头到尾实现一个应用。这之后的学习方向就开始从js脱离出来，而是进行软件逻辑、产品逻辑、代码逻辑这些思考和实践了，要考虑服务端运行环境，以便编写一些自动化的工具（shell编程等）。再之后需要考虑的就是服务器架构，负载均衡等。目前我还想不到更细致的关注点了。</li><li>说了这么多，其实只是让自己捋一下web前端的工作内容，以便自己明确要在近期和中期学习的知识以及要做的实践。</li><li><strong>总结一下</strong>，从工作的角度出发，现在最常见的还是前端负责view，后端由java或php负责逻辑，采用php文件或jsp文件作为html模板文件。前端与后端数据交互多采用ajax，数据格式使用json，收到ajax传回的数据后使用js（或js库）操作dom实现动作。负责最多的部分是html和css，需要编写各类小组件和动画（或其他）效果。需要清楚了解div布局和css兼容。需要熟练使用jquery操作dom以及熟练使用bootstrap组件库进行快速搭建。需要使用js处理一些数据（例如将json数据写到table中）。需要培养自己的美感和简单的页面设计能力（画图估计emmm），需要收集好的有创意的页面布局形式。</li></ul><h3 id="vue知识点"><a href="#vue知识点" class="headerlink" title="vue知识点"></a>vue知识点</h3><ul><li>vue组件，一个web应用可以拆解成多个组件，组件可大可小，因此组件的一个重要部分就是如何拆分，可以按照功能划分，也可以根据视图划分。例如根据视图划分，把一个页面拆成header、maincontent、sidebar、footer几个大的组件，那么对于这个网页来说，这几个大的组件就是顶层组件。从文件上来看，index.html文件就包含了header…这几个标签</li><li>vue组件要传递数据，需要在单组件文件的导出对象中，添加<code>props</code>属性，可以使用数组（最简单的），也可以使用对象（用于规定值类型）。</li></ul><h2 id="我的尝试"><a href="#我的尝试" class="headerlink" title="我的尝试"></a>我的尝试</h2><p>详见netease的项目试用。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul><li>组件中如何让template（v-html）实现组件的调用？是否可行？</li><li>webpack打包后，要如何给vue对象传递数据？ajax回来的数据如何进行赋值？</li><li>webpack打包后，对象如何进行调试？（和2类似）</li><li>全局组件与局部组件的优劣势？为何使用组件？组件的复用如何实现？</li><li>webpack打包时，如何识别vue对象终中绑定的如src这类资源地址？解决如何能使静态资源被打包？</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue学习记录+node部分学习3</title>
    <link href="undefined2019/09/11/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A03/"/>
    <url>2019/09/11/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A03/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><ul><li>vue全家桶包括<code>vue+vue-router+vuex+axois+vue-devtools+vue-cli</code>，这几个工具就足以支撑一个大型web前端页面的开发调试工作。因此学习vue的实质，是要掌握这些工具的使用，熟练使用并理解。</li><li><code>vue</code>是一个构建前端界面的渐进式（虽然我也不懂）框架，核心是数据绑定，用数据驱动视图。两个关键点：指令、组件，指令是实现数据绑定以及一些其他功能的实现方式，组件是解构了web页面得到的基础，因此前端界面变成了开发组件，并用指令绑定数据的工作。</li><li><code>vue-router</code>是用于构建单页应用的工具，名称为<code>路由</code>，实质是根据路径显示页面的不同部分，可以减少客户端重复向服务器发起请求的过程，在首次渲染完成后，再浏览其他页面，速度将会比较快，且不受网络情况的影响。</li><li><code>vuex</code>是vue实例的状态管理器，据说是可以实现不同vue实例间的数据交互，还不懂啊。</li><li><code>axios</code>是浏览器中或node中用于发起http请求的工具，在浏览器中，相当于ajax类似的存在，发起异步请求，具体好用与否，还需实践一下。</li><li><code>vue-devtools</code>是vue应用开发模式下的浏览器调试工具，可以查看vue实例的各种状态。</li><li><code>vue-cli</code>是一个工程化开发构建工具，可以用于生成工程文件，不需要人工进行大量复杂的配置，在快速开发时非常好用，但作为初学者，我还是应当在理解了工程目录以及配置文件之后，再来使用这个工具。</li></ul><ul><li>学习资料：<a href="http://doc.liangxinghua.com/vue-family/1.html" target="_blank" rel="noopener">vue全家桶文档</a></li></ul><p>##一些尝试</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul><li>学习vue的过程中，没有一些比较实际的例子，往往会造成不知道学了一个知识点能怎么用的状况，因此在学习记录中，一定要写上自己的一些尝试，把这些尝试要有实际的代码，要能够说明用处，这样才能使自己的思路更加清晰。</li><li>在写案例代码时，要达到以下要求：<ul><li>用比较简短的语言说明问题所在。</li><li>用简短的语言解释解决问题的思路。</li><li>展示核心代码。</li><li>用简短的语言说明代码做了什么。</li><li>额外的说明，这样做的价值是什么，将来可以用在什么地方。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术学习规划</title>
    <link href="undefined2019/09/11/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"/>
    <url>2019/09/11/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="技术学习规划"><a href="#技术学习规划" class="headerlink" title="技术学习规划"></a>技术学习规划</h1><p>算起来学习web前端也有很长一段时间了（从3月算起，已经有6个月了），虽然过程中并非全心在学习web技术，或者可以说专心学习的时间是很少的。</p><p>3月初到4月初，是兼顾着审计实习的工作学习的，每天被繁杂的审计琐事环绕着，很少有时间系统性地学习技术，4月初到6月初的时间，学习了一段时间html、css、js基础、jquery基础这些基础知识，但同时兼顾着毕业设计写论文，每天的学习效率十分低下，过了论文答辩后，就是7月初的时候了，7月初到8月初在北京学了一段时间，但那时对要学习的方向十分模糊，每天迷迷糊糊，不知道要学些什么，这里弄一下，那里弄一下，时间也就很快过去了。然后就是8月初来到广东，一直到现在，一个月时间内，有一半的时间是迷糊着过去的，做做饭、玩玩手机就这样过去了，学习的时间也不足，因此，虽然说起来已经学习了很长时间了，但实际自己学习的东西非常少。</p><p>我算是一个不十分自信的人，会经常觉得自己似乎什么都做不了，但是身边一些朋友会认为：有个还算不错的学历，性格不错比较好相处，算是比较上进，做各种事情看起来比较得心应手，那么就不会是一个一无是处的人。但我似乎还是找不到自己的方向，常常陷于各种迷茫之中，尤其是越临近工作，越是无所适从。</p><p>之前问过自己一个问题：我的竞争力是什么？回顾自己的成长历程，我得出的答案是：学习能力。可能随着时间的推移，我会把“经验”“圈子”“心态”这三个关键词加上，但“学习能力”是永远排在第一位的。</p><p>从上面我的学习过程来看，我完全没有把自己看重的“学习能力”发挥出来！这是非常值得深思的事情。</p><p>学习为什么会很辛苦？是由于缺乏“目标”，具体而言，不知道自己学了什么，不知道自己在学什么，不知道自己要学什么。因此要消灭学习过程中的三座大山，就要解决好这几个问题——制定明确的目标。</p><p>除了目标外，在执行过程中，还要记录好自己的学习过程，这样才能让自己思考：学了什么，有什么收获，跟之前的有什么关系，跟之后要学的有什么关系。也才能让学习更加连贯和系统。</p><p>目标制定要有一定的原则，smart，明确、可观测、可达、关联、时限。但同时，计划具有不确定性，因此时间跨度越长的计划，越应当宽泛，时间跨度越短的计划，越应当具体。从实际经验来看，较长时间的具体计划，缺乏了计划的灵活性，总会因为一些小的事情被打破，最终计划破产，费时费力却无收获。</p><p>由于我是一个初学者，对于技术路线了解不深，因此无所凭据地拍脑门定计划是一个非常不负责的举动，因此应当尽量参照比较成熟的教程，制定自己的学习计划。虽然有时候看起来他人的学习路线不符合自己的事情，例如有些内容对自己而言似乎很简单，但实际经验来看，即使认为很简单的内容，自己的理解也非常有限，总能从中获取更多的思考，甚至有时候这种思考比其他单纯获取知识来得更加高效。</p><h2 id="我的学习思考"><a href="#我的学习思考" class="headerlink" title="我的学习思考"></a>我的学习思考</h2><p>低效率学习了这么久，有几个一定要关注的事情：<br>    ①一定要明确地学习某一个系列的学习资料。<br>    ②一定要给学习这个系列资料做笔记，包括知识记录和问题记录以及自己的尝试。<br>    ③一定要给学习某内容的时间做稍紧张的安排，在某一段时间内要完成这个内容的学习。<br>    ④一定要给学过的内容做总结性思考，梳理自己学到了什么，有什么用。<br>    ⑤一定要实践，并把实践的过程和结果用比较规范的结构保存下来。</p><p>我要学习的主线：以web前端为入口，深入学习js，进而以node为环境进入后端，与此同时学习掌握java，了解php。<br>我的时间线：web学习时间仅有20天左右，之后还有15天用于全心学习注会会计，10月21日之后开始全心找工作。<br>我要学习的内容：①vue。②js。③jquery。④elementUI。⑤bootstrap。⑥html。⑦css。⑧webpack。⑨socket。<br>我要达到的效果：①把B站内容完善。②写好自己的博客系统。③用vue深度还原网易云课堂。④用bootstrap或elementUI写一个后台管理界面。⑤写一个简历。⑥用node写一个后端服务（智慧家居后台）。⑦设计一个生活规律看板。</p><h2 id="现在的学习控制"><a href="#现在的学习控制" class="headerlink" title="现在的学习控制"></a>现在的学习控制</h2><p>学习控制上：①明确的学习内容（vue，js），②规范的知识记录（写博客），③固定的学习时间（每天需学习12小时以上）<br>明确的学习内容：①<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">nodebeginner</a>,②<a href="https://cn.vuejs.org/v2/cookbook/" target="_blank" rel="noopener">nodejs官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue学习记录+node部分学习2</title>
    <link href="undefined2019/09/10/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A02/"/>
    <url>2019/09/10/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<h2 id="基础属性与指令"><a href="#基础属性与指令" class="headerlink" title="基础属性与指令"></a>基础属性与指令</h2><ul><li>列表渲染(上接9.9vue学习)<ul><li>列表渲染，就是使用<code>v-for</code>指令进行的渲染，data可以为数组，也可以为对象，或者是数组对象。</li><li>使用数组，<code>v-for=&quot;(item,index) in/of items&quot;</code>的形式，<code>app.data={items:[&quot;hey1&quot;,&quot;hey2&quot;,&quot;hey3&quot;]}</code>。</li><li>使用对象，<code>v-for=&quot;(value,key,index) in items&quot;</code>，同时，<code>app.data={items:{key1:&quot;value1&quot;,key2:&quot;value2&quot;...}}</code>。</li><li>使用数组对象，<code>v-for=&quot;(item,index) in items&quot;</code>，同时，<code>app.data={items:[{key:&quot;value1&quot;,key1:&quot;value2&quot;},{key:&quot;value3&quot;,key1:&quot;value4&quot;},...]</code>，可以使用这类方式。</li><li>需要注意的是，要添加数组时，可以使用<code>pop/push/unshift/shift/splice/sort/reverse</code>这些方法，而不能使用<code>arr[n]=xxx</code>这样的方式，这样不会被vue检测到依赖变化。这种情况可以采用splice进行替代，也可以采用vue提供的全局方法Vue.set(app.items,indexof,value)进行替代。</li><li>同样，在使用对象进行v-for时，需要提前把对象的属性定义好，渲染过后再添加新属性的，无法被vue检测到，例如无法使用<code>app.$data.items.key3=value3</code>这样的形式。同样，可以使用<code>Vue.set(app.items,key,value)</code>的形式进行添加。</li><li>数组对象在vue组件中会非常有用。</li><li>vue的官方文档中，对于todolist的设计，需要再仔细捉摸一下，尤其是在component的<code>is=&quot;todo-item&quot;</code>的理解。</li></ul></li><li>事件处理<ul><li>指令为<code>v-on:xxx=&quot;xx&quot;</code>或者缩写为<code>@xxx=&quot;xx&quot;</code>，其中xx为methods对象中的方法名，或者直接为js表达式，例如<code>@click=&quot;counter ++&quot;</code>这类。</li><li>和js一样，在出发event事件后，函数都会默认有一个event对象作为参数输入，可以使用function(e){}来接收参数。v-on也可以输入参数，形式为<code>@click=&quot;counter(&#39;heihei&#39;)&quot;</code>，若已经有参数输入，还想要接受event对象，则可以通过counter(“heihei”,$event)的形式传入。</li><li>如同js处理事件的冒泡机制或有预定义事件的动作一般，需要先preventDefault()，然后再进行函数执行。vue中提供了“修饰符”这样的概念来实现，代码方式为<code>@submit.prevent=&quot;xxx&quot;</code>，就可以阻止原本的submit跳转。同系列修饰符还有：<code>.stop/.prevent/.once/.capture/.self/.passive</code>。具体用法，还需要再学习js后回头来思考。</li><li>键盘修饰符的使用还是比较好用的，之前使用js或jquery进行表单交互时，若想监听用户是否输入了<code>enter</code>键，就需要对每一个keypress事件进行监听，然后判断keycode==13是否为真，vue提供的键盘修饰符<code>@keypress.enter=&quot;&quot;</code>就可以直接实现。</li></ul></li><li>表单绑定<ul><li>指令为<code>v-model=&quot;xxx&quot;</code>，实质上不是什么新东西，vue官方教程上说这只是一个语法糖。</li><li>表单的input:type有多种，根据种类的不同，v-model的值形式也不一样，text即为value，button也是value，没有value时radio和checkbox是checked，有value是radio和checkbox是value，textarea是value，select是selected。</li><li>复选框中的v-model，可以使用true-value=’’和false-value=’’的方式，使得v-model的值有不同的输出。例如<code>&lt;input type=&quot;checkbox&quot; v-model=&quot;chebox&quot; true-value=&#39;yes&#39; false-value=&#39;no&#39;&gt;</code>，这样chebox的值就分别为yes或no。</li></ul></li><li>组件基础<ul><li>为了使组件可以复用，因此在注册component时，data不能是一个对象，而是用function(){return {}}，这样才能够使得每次调用该组件时，都是新的data，相互之间不影响。<em>ps：</em>这里不知道为什么，虽然估计是对象的引用方式产生的问题，但具体产生原因需要深入学习探索。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue学习记录+node部分学习</title>
    <link href="undefined2019/09/09/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A0/"/>
    <url>2019/09/09/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95+node%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>和其他库类似，vue可以通过script标签直接嵌入到js文件，这会使得在注册一个vue全局变量，有两个版本，生产版本和开发版本，因此可以使用<code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;</code>或者从自己的文件夹中直接引用。</li><li>但一般来说，我们在使用vue的时候，都是在node环境下的工程化开发，因此直接<code>const vue = require(&quot;vue&quot;)</code>就可以了，然后在js文件中配置vue的相关属性即可；由于vue-cli提供了比较好用的脚手架，例如集成了webpack的、或者集成了elementUI的等等，我们可以更加方便地直接在node中使用<code>vue init webpack</code>等直接生成脚手架。</li><li>但是由于我对vue的基础了解并不深，因此在vue的这次学习过程中，将从最最最基础的vue文件构建开始，逐渐深入到使用webpack等工具对vue进行预处理并使用webpack-devserver进行调试工作。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>vue的第一步，初始化，使用<code>let app = new Vue({});</code>，然后就可以在app中添加各种属性，例如最最最基础的<code>app.el = &quot;#app&quot;</code>，这是用于绑定html中的元素，给了vue一个作用的范围。</li><li>既然可以直接通过更改数据而改变dom，那么也就意味着要让数据和dom绑定起来，最简单的文本插值方式<code>\{\{message\}\}</code>就可以与<code>app.data = {message : &quot;hello vue&quot;}</code>建立联系。</li><li>除了文本的插值，我们经常要操作的其实是节点的各种属性，那么就可以在html中使用<code>v-bind：title = &quot;thetitle&quot;</code>的方式与<code>app.data = {thetitle : &quot;this is a title&quot;}</code>建立联系。</li><li>在操作节点属性时，除了要经常定义节点属性的值，有时候还会进行判断，是否需要将这个元素显示出来，这时可以使用<code>v-if = &quot;seen&quot;</code>与<code>app.data = {seen : true/false}</code>进行联系，那么该元素就会根据seen的值为true而显示，false则不显示。（姑且认为与绑定css的display相似，不知道是否有更加有用的地方）。</li><li>在传统写页面时，有一个特别大的烦恼，列表什么的，在编写时非常费事，经常需要单独去定义，或者在js中使用for循环去持续输出，相对比较麻烦，在vue中可以采用<code>v-for = &quot;todo in todos&quot;</code>的形式进行重复项渲染，例如<code>&lt;ul&gt;&lt;li v-for = &quot;todo in todos&quot;&gt;\{\{todo.content\}\}&lt;/li&gt;&lt;/ul&gt;</code>来输出<code>app.data = {todos: [{No:1,content:&quot;learn vue&quot;},{NO:2,content:&quot;eat&quot;},...]}</code>。</li><li>一个页面，除了要展示给用户内容外，还要能够接收用户的输入并产生反馈，因此，处理用户数据输入也是非常重要的一个方面，之前的编程中，我们大都使用<code>onclick=&quot;submit()&quot;</code>来调用函数，然后函数中来接收用户输入状态<code>function submit() {let danmu = $(&quot;form input:text&quot;).val(); ...}</code>，使用vue后，可以将数据进行双向绑定，<code>&lt;input type = &quot;text&quot; v-model = &quot;danmu&quot; /&gt;</code>就可以直接和<code>app.data = {damu: &quot;&quot;}</code>进行绑定，无论是改变哪一侧，两边的数据都会改变。</li><li>js的作用说起来无非有两个，一个是接收用户的动作，另一个是根据用户的动作改变浏览器的动作，也就是交互，前面的内容让那个基本都是后者，也就是需要浏览器做些什么。前者在先前的编程中，会使用<code>$(&quot;xxx&quot;).on(&quot;&quot;, function(){})</code>或者使用原生js语句<code>getElementById(&quot;xxx&quot;).addEventLisenter(&quot;xxx&quot;,function(){})</code>这样的方式，而在vue中，可以直接使用<code>&lt;button v-on:click = &quot;submit&quot;&gt;Submit&lt;/button&gt;</code>的方式和<code>app.method = {submit : funtion(){xxx\}\}</code>进行绑定。</li></ul><h2 id="vue的知识点"><a href="#vue的知识点" class="headerlink" title="vue的知识点"></a>vue的知识点</h2><h3 id="基础属性与指令"><a href="#基础属性与指令" class="headerlink" title="基础属性与指令"></a>基础属性与指令</h3><ul><li>插值<ul><li>文本插值。最基础的往html中插入数据的方式是<code>\{\{xxx\}\}</code></li><li>html插值。若想插入的值是html模板，例如<code>&lt;a xx&gt;xxx&lt;/a&gt;</code>，就不能使用双大括号，而要使用v-命令<code>v-html=&quot;xxx&quot;</code>的形式，例如<code>&lt;span v-html=&quot;hei&quot;&gt;&lt;/span&gt;</code>。<em>ps：</em>这看起来就像是template一样，但vue不推荐这样做，原因是可能会遭受xss攻击（暂时不懂），而tempelate最好是采用component的形式。</li><li>有些插值只想使用一次，不希望后面改变，就使用命令<code>v-once</code>，例如<code>&lt;span v-once&gt;\{\{\}\}&lt;/span&gt;</code>。</li><li>插值不仅仅只能绑定app.data中的数据，还能够直接进行运算，例如<code>&lt;span&gt;\{\{number + 1\}\}&lt;/span&gt;</code>或者<code>&lt;span&gt;\{\{message.split(&quot;&quot;)[2]\}\}&lt;/span&gt;</code>或者<code>&lt;span&gt;\{\{ok ? yes : no\}\}&lt;/span&gt;</code>等这样的js语句，但是双大括号中，只能处理单表达式，且都是在沙河中运行的，所以无法定义全局变量等操作。</li></ul></li><li>指令<ul><li>vue的指令都是以<code>v-</code>开头的，例如<code>v-bind/v-on/v-if/v-for/v-html/v-once/v-model</code>等。有些指令需要参数，有些不需要，例如<code>v-bind:title=&quot;xxx&quot;</code>其中这里的title就是参数，而<code>v-if=&quot;seen&quot;</code>就没有参数。</li><li>总结起来，指令可以写成这样的形式<code>v-bind:[attribute]=&quot;xxx&quot;</code>以及<code>v-on:[event]=&quot;xxx&quot;</code>，其中中括号括起来可以用于执行js，例如<code>v-bind:[tt]=&quot;xxx&quot;</code>在data中tt=title的话，那么渲染后为<code>v-bind:title=&quot;xxx&quot;</code>。</li><li>在这些指令中，有两个指令用的特别多，一个是v-on，另一个是v-bind，之前的经验就知道，一个是给元素属性赋值，另一个是给元素添加监听事件，因此这两个指令给了缩写，v-bind的缩写<code>:</code>，v-on的缩写为<code>@</code>。</li></ul></li><li>计算与侦听<ul><li>之前在插值中说过，<code>\{\{ \}\}</code>中可以使用简单的js运算，但是从代码的维护来说，把计算的表达式写到template中似乎有些不妥，至少在读代码的时候看起来会很不自然，因此对于数据的处理，可以直接在vue对象中进行，这就是vue的另一个属性—计算属性computed。</li><li>例如我们想把两个数据male和female加起来，在vue中有这样的数据<code>app.data={male:10,female:20}</code>,<code>app.computed={all: function(){return this.male+this.female\}\}</code>，这样，在template中就可以使用<code>\{\{all\}\}</code>而不是<code>\{\{male+female\}\}</code>的形式。</li><li>这里，computed使用了一个getter的方法，直接返回运算后的结果。另一个是在return中，使用的是this.male，male这个字面量是在data属性代表的对象内的，这样使用为什么可以实现？这需要查阅this指代，以及getter和setter的使用方式。</li><li>上面这个male和female的例子，使用<code>\{\{all\}\}</code>和使用<code>\{\{all()\}\}</code>（前提是把all从computed移到method中去）能达到同样的效果，前者是使用的计算属性，后者是使用的方法调用，两者的差别是前者有缓存，前者是先计算好一个值，多次调用都依然只是一个值，后者是重新计算一次。</li><li>侦听属性是一个可以观测data变化的对象，写法为<code>app.watch={xxx: function(xx){}</code>也就是当xxx数据发生变化时，传入变化后的值xx并执行函数。听着好像很好用，所以vue认为可能会被滥用，说到底，watch始终是一个检查依赖的方法，computed属性也有这样的功能，因此主要用于计算的时候，可以直接用computed属性。</li><li>computed属性中，默认的为getter，但是我们也可以设置setter，<code>app.computed={hei:{get:function(){},set:function(xx)\}\}</code>，这样就可以使用<code>\{\{hei=&quot;xx&quot;\}\}</code>来进行设置。</li></ul></li><li>class绑定<ul><li>前端元素最常用的两个属性应该就数class和style了，因为样式基本都靠这两个属性撑起来了，因此vue也应当对这两个属性的使用提供一些便利。通常来说，属性都可以使用<code>v-bind:</code>或者简写成<code>:</code>来绑定数据，但如果绑定的内容是class，可以使用对象或者数组来传入，作为对class属性的增强。</li><li>例如<code>&lt;div :class=&quot;{alert:isalert,reddy:isred}&quot;&gt;&lt;/div&gt;</code>的方式，在app.data={isalert:false,isred:true},渲染出来就是<code>&lt;div class=&quot;reddy&quot;&gt;&lt;/div&gt;</code>。</li><li>数组的运用：<code>&lt;div class=&quot;[alert,reddy]&quot;&gt;&lt;/div&gt;</code>同时app.data={alert:alert,reddy:reddy}，就会渲染出<code>&lt;div class=&quot;alert reddy&quot;&gt;&lt;/div&gt;</code>。</li><li>所以，对于要判断是否需要给xxclass的时候，就用对象输入，或者用三元表达式+数组，要直接给多个xxclass的时候，就用数组输入。另外，都可以使用computed属性进行比较复杂的class绑定。</li></ul></li><li>style绑定<ul><li>style的对象形式比较好理解了，在jquery.css()传值的时候，也是使用类似的方式，不过这里的对象中的value其实是vue中的data对象的键名或者computed对象的键名，会被转换成键值。</li><li>sytle的数组形式也比较类似，就是传入多个data或computed对象。</li><li>其实为了形式更加简洁易懂，最好还是把style直接写到vue中，例如<code>app.data={sty1:{width:20%,color:#fff...\}\}</code>这种形式。</li></ul></li><li>条件渲染<ul><li>指令包括：<code>v-if/v-else/v-else-if/v-show</code>。其实就是根据一个data值（或者是逻辑运算或computed）确定是否渲染，或者是否显示的问题。</li><li>在用v-if和v-else时，如果有相同的元素，会被vue复用，意味着如果有输入框等内容，则v-if和v-else替换时，内容不会被换掉。要想打破这一复用，需要给元素添加不同的属性<code>key = &quot;xxx&quot;</code>。</li><li>v-show和display的样式是一样的，会被渲染进dom，但是不显示。</li></ul></li><li>列表渲染<ul><li>后接9.10vue学习记录</li></ul></li></ul><h2 id="vue的组件化"><a href="#vue的组件化" class="headerlink" title="vue的组件化"></a>vue的组件化</h2><ul><li><code>组件化</code>这个词绝对是值得关注的，不论是做编程的哪个方向，<code>组件化</code>可以让代码的复用性增强，让编程的逻辑更加清晰，在前端中也一样，这是前端的<code>5化（工程化、模块化、组件化、自动化、规范化）</code>趋势中的一个，因此需要重点关注。</li><li>vue中的组件意味着可以使用自定义的标签和自定义的属性，渲染出一个完整的template，并且通过自定义属性把值传递给该template，让其有相应的变化。</li><li>响应的代码为<code>Vue.component(&quot;componName&quot;,{props:[prop],template: &quot;&lt;xx&gt;{prop.hei}&lt;/xx&gt;&quot;})</code>这样就可以直接在html中使用<code>&lt;componName prop ={hei:xxxx,...} &quot;hei&quot;&gt;&lt;/componName&gt;</code>来实现template中的代码。</li></ul><h2 id="vue是什么"><a href="#vue是什么" class="headerlink" title="vue是什么"></a>vue是什么</h2><ul><li>从直观上来看，vue的第一个作用是可以绑定数据，也就意味着我们只需要更改变量的值，DOM渲染则交给vue负责，这与之前使用jquery或者使用原生js编程有着极大的差别，也就是我们不需要使用各种语句去写DOM，不用大量的<code>$(&quot;.xx/#xx/...&quot;).on()/css()/...</code>这样的语句了，这为我们前端减少了大量的重复性工作。不用亲自操作dom的一大优势，就是我们可以更加着眼于业务逻辑的处理，使用js处理各种业务逻辑，在当下看来，这是更具有价值的工作。</li><li>从编程时操作逻辑摆放的位置来看，vue是将操作逻辑或者数据映射直接放在了html的template中，然后再vue对象中将这些操作实现和数据进行归集，之前的编程基本都把操作逻辑和操作实现放在了一起（例如jquery是直接选取元素紧接着就实现操作），vue的这种方式在一定程度上让编程的逻辑更加清晰。但这样做是否一定是有利的？我觉得不一定，jquery的很多函数可以直接复用，在vue的对象化封装下，函数的复用性如何？还需要进一步学习研究。</li><li>vue说起来很符合MVVM的模型，vue在这个模型中，负责vm的部分，M由服务器传来的数据负责，V由浏览器的DOM负责，我对设计模式几乎一窍不通，仅在看java的ssh时了解了一下mvc模式（model-view-controllor），在看node的时候有人提到观察者模式，其他的就一概不知了。后续需要补充这方面知识。</li></ul><p><em>用node建立服务器</em></p><ul><li>综合说明1：要想创建一个web服务器，最基础的需要有①ip地址、②监听端口、③返回内容，这就是一个web服务器最最最简单的需求，至于接收到什么样的请求返回什么样的内容，就是后端程序需要做的事情了。以前的web服务器建立，需要使用IIS、Apache、nigx或者tomcat等web服务器程序，他们各有各的特点，在使用php、java等语言编写后端程序时，这些服务器程序可以很方便地提供服务，其实质，大致也是监听端口、建立连接、过滤数据、转发信息、映射loader、发送内容这类。</li><li>综合说明2：使用node作为后端环境的情况下，不需要上述的服务器程序，而是通过运行js程序，直接监听端口、建立连接、信息传递、信息处理、文件传输等。而这些功能，不再是通过配置文件进行配置，而是被集成到了node的各类模块中，通过调用api进行编程，要建立web服务器，就可以使用下述方法。</li><li>方法1：使用http模块建立web服务器<pre><code>const http = require(&quot;http&quot;);//导入http模块let hostName = &#39;127.0.0.1&#39;;//定义hostname，将来可能会用得上let port = 80;//定义监听的端口</code></pre></li></ul><p>//创建服务器<br>const srv = http.createServer((req,res)=&gt;{<br>    //当接收到消息时，返回头部，第一个参数为状态码，第二个参数为头部（具体内容详见http头部信息）<br>    console.log(req.headers);<br>    res.writeHead(200,{<br>        “content-type”:”text/plain”<br>    });//类似于res.statusCode + res.setHeader(“”,””)<br>    res.write(“hey , you just create a http server !”);//返回对应的内容，可以是字符串，也可以是拼接的数据，或者传输二进制文件等<br>    res.end();//内容传输完毕<br>});<br>srv.listen(port,hostName,()=&gt;{<br> console.log(<code>server is already on , listening port %d</code>,port);<br>});//服务器监听端口</p><pre><code>* 方法2：使用express模块建立web服务器</code></pre><p>const express = require(“express”);<br>const fs = require(“fs”);<br>const url = require(“url”);</p><p>const app = express();<br>const hostName = “127.0.0.1”;<br>let port = 80;</p><p>app.use(express.static(__dirname+”/src”));</p><p>app.get(“*”,(req,res) =&gt; {<br>    console.log(“asking url : %s “,req.path);<br>    console.log(“asking query : “,req.query);<br>    let filename = null;<br>    let pathname = url.parse(req.url).pathname;<br>      //当请求static文件夹时，设置文件返回类型是text/css<br>    let firstDir = pathname &amp;&amp; pathname.split(‘/‘)[2];<br>    console.log(pathname);<br>    console.log(pathname.split(‘/‘));<br>    let ContentType = null;<br>    if (req.path == “/“) {<br>        filename = “./index.html”; //默认为index.html<br>        ContentType = {“Content-Type”:”text/html”};<br>    }else {<br>        filename = “.”+req.path;<br>        ContentType = {“Content-Type”:”text/plain”};<br>    }<br>    console.log(“filename : “,filename);<br>    fs.readFile(filename,(err,data) =&gt; {<br>        if (err) {<br>            console.log(err);<br>            res.send(“something wrong with the file”);<br>        }else {<br>            res.writeHead(200,ContentType)<br>            res.write(data);<br>        }<br>        res.end();<br>    });<br>});</p><p>app.post(“*”,(req,res) =&gt; {<br>    let body = req.body;<br>    console.log(“request parms : “,body);<br>    res.send(“hey you sent a post request !”);<br>});</p><p>app.listen(port,hostName,()=&gt;{<br>    console.log(“server is runing at %s:%s”,hostName,port);<br>});</p><pre><code>* 上述只是用最简单的方式建立了一个监听程序，以及最简单的后端路由，从node的http文档以及express文档来看，还有非常多的功能，待后续边实践边学习。* 在使用## 一些问题* vue注册全局变量是如何实现的，以及jquery或elementUI在注册一些专有标签和属性时是如何实现的，或许需要查看html的自定义元素与自定义属性等知识。暂时无法理解，在能够使用vue做项目后再去理解其原理。* 在使用express创建服务器时，需要返回文件类型，使用text/html作为html文件类型，使用text/css作为css文件类型，使用text/plain作为字符串等数据传输，也就意味着在写服务端程序时需要先进行判断，那么其他类型例如js、jpg等文件类型又该如何传输呢？MIME类型？除了返回的类型需要判断外，在获知需要返回的类型上也比较麻烦，server2.js的例子中采用的url.parse(req.url).pathname.split(&quot;/&quot;)\[2\]这样复杂的方式，是否有更加简单的呢？例如express-static？</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arduino小车问题记录</title>
    <link href="undefined2019/09/06/arduino%E5%B0%8F%E8%BD%A6%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>2019/09/06/arduino%E5%B0%8F%E8%BD%A6%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h4 id="问题及方向"><a href="#问题及方向" class="headerlink" title="问题及方向"></a>问题及方向</h4><ul><li>当前，已经能够对与arduino相连接的多项传感器进行简单通信，获取传感器信号（声音检测、人体运动检测、超声距离检测、温湿度检测），以及将传感器信号转化成较好理解的输出（解释字符串输出），并且能够给部分执行器下达指令（moto、servo、超声测距、小喇叭）。</li><li>在代码规范上，实现了几乎全文注释，遵守先申明后使用的原则，遵守将复用功能函数封装的原则，遵守字面量命名的驼峰规则（还应当保持命名习惯的一致性）。</li><li>在与arduino的通信上，采用了自行定义的<code>命令+：+参数+；+下一个命令</code>的方式，命令采用4位的十进制数字，已经预定义一些常用的命令，并给现在未能实现的命令预留了命令位置，以保证后续的可拓展性。</li><li>现在出现的一些问题：<ul><li>左右两侧moto的转速不统一，无法实现走直线，虽然采用了<code>标准速度</code>这样的方式希望进行手动调速，然后假设速度变化是随着电压成正比，采用以一个moto的速度为基准，另一个成倍速变化，但实际使用起来偏差太大，经常出现一只脚停止转动，而另一只脚的速度依然很快的情况。</li><li>超声测距的问题，经常出现1200cm这样的数据，而且当产生这样的数据时，舵机的转动开始受到阻碍（估计是超声占用时钟的时长增加）。产生的原因暂时估计可能有两个：①杜邦线的连接不稳定；②超声面对的对象为非光滑的面，导致声波的传导出现障碍。</li></ul></li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arduino小车项目新增部分</title>
    <link href="undefined2019/09/02/arduino%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE%E6%96%B0%E5%A2%9E/"/>
    <url>2019/09/02/arduino%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE%E6%96%B0%E5%A2%9E/</url>
    
    <content type="html"><![CDATA[<h4 id="增加部分"><a href="#增加部分" class="headerlink" title="增加部分"></a>增加部分</h4><ul><li>增加一个舵机，做成一个二自由度的小云台。二自由度的云台可以用于进行超声波雷达。</li><li>将语音采集传感器从数字信号换成模拟信号。（试用之后，觉得现阶段还是检测声音用起来更方便，语音采集试验之后再做，或许专门用一块板子进行声音采集）</li></ul><h4 id="逻辑总结"><a href="#逻辑总结" class="headerlink" title="逻辑总结"></a>逻辑总结</h4><ul><li>仅仅是最基础的代码和组件其实意义不是特别大，因为arduino的库非常丰富，简单的传感器的使用也非常简单，因此做arduino的编程，重点在于对其逻辑的把控，也没有见到一些比较成熟的arduino项目的代码用于模仿，因此我也不清楚比较好的代码逻辑是怎样的，只是按照自己的习惯性操作和理解来写的。</li><li>我当前主要的思路是：所有与传感器相关的底层操作，简单的操作则自己进行函数封装（例如简单的人体运动检测、声音检测等），复杂的操作使用库进行拓展（例如servo库、DHT库），所有的重要参数使用全局申明的方式，在函数中可以直接调用参数（也有一个传值的声音播放函数）。</li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><ul><li>总结能够输入的指令和要输出的数据：<ul><li>输入的指令：<ul><li>小车左转<code>指令``1001+0~180</code></li><li>小车右转<code>指令``1002+0~180</code></li><li>小车速度<code>指令+速度``1011+0~100</code></li><li>小车标准速度<code>指令``1012</code></li><li>小车停下<code>指令``1015</code></li><li>舵机hr转动<code>指令+角度``1101+0.0-180.0</code></li><li>舵机ve转动<code>指令+角度``1102+0.0-180.0</code></li><li>超声测量距离<code>指令``1201</code></li><li>超声雷达模式<code>指令+角度范围``1202+0.0+180</code></li><li>小车播放指定声音<code>指令+指定声音``1301+0~5</code></li><li>小车播放传入声音<code>指令+传入声音``1302+0~7(调)+[](音调)+[](节拍)</code></li><li>小车打开/关闭灯光<code>指令+状态``1401+0~F</code></li><li>小车检测是否有人<code>指令``1501</code></li><li>小车检测是否有声音<code>指令``1601</code></li><li>小车检测环境温度<code>指令``1701</code></li><li>小车检测环境光照<code>指令``1801</code></li><li>小车检测灯光状态<code>指令``1901</code></li><li>小车初始化状态<code>指令``2001</code></li><li>小车进入休眠模式<code>指令``2101</code></li><li>小车唤醒<code>指令``2501</code><ul><li>举几个例子：</li></ul></li></ul></li><li>小车左转80度，[1001:80]</li><li>舵机hr转动到90度，[1101:90]</li><li>超声雷达模式，[1202:0:180]</li><li>上述三个命令合并，1001:80;1101:90;1202:0:180;<ul><li>因此在解析命令时，需要对<code>:</code>和<code>;</code>这两个符号进行划分，分别储存进一个int二维数组，由于目前没有找到定义不定长二维数组的申明方式，可暂时采用定长二维数组，每个命令的长度为4，第一个为命令，后三个位参数，命令组的长度暂定为3。</li></ul></li></ul></li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arduino小车项目尝试</title>
    <link href="undefined2019/08/30/arduino%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/"/>
    <url>2019/08/30/arduino%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><ul><li>室内定位技术当前还没有形成完善的技术体系，整体来说，有<code>wifi室内定位``蓝牙室内定位``超宽带``RFID``超声波``红外</code>等几种，各有应用场景，但从精度上来说，都还是有一定局限，当前的应用主要集中在商场导航、停车场定位、库房货物定位等方面，但在精确定位上的应用还十分匮乏，例如用于机器人位置感知等。近场导航用机器人视觉的方案更可靠一些。参考资料：<a href="http://m.elecfans.com/article/586741.html?fromtype=app" target="_blank" rel="noopener">10种室内定位技术</a>。</li><li>在调试PWM时发现一个现象，我一开始用的是A0和A1作为使能端输出口，但是发现怎么改变analogWrite的值速度都没有变，并且，只有当值大于等于128时，电机才能转动，所以想找到问题的原因。最终通过A0输出，A1输入并用串口输出，发现了问题所在：A0-A5是模拟信号输入口，并不能直接输出模拟信号，而且analogWrite的输出寄存器为8位，也就意味着将转化为二进制的格式，当值小于128时，二进制数的首位为0，输出直接为0，大于等于时，输出为1。</li><li>为什么analogWrite的值为0-255，而analogRead的值为0-1023呢？是由于前者为8位寄存器，后者为10位寄存器。（具体内容估计得查看硬件参数了）。</li></ul><h2 id="一些尝试"><a href="#一些尝试" class="headerlink" title="一些尝试"></a>一些尝试</h2><h3 id="arduino项目（继8-29）"><a href="#arduino项目（继8-29）" class="headerlink" title="arduino项目（继8.29）"></a>arduino项目（继8.29）</h3><h4 id="对arduino的理解"><a href="#对arduino的理解" class="headerlink" title="对arduino的理解"></a>对arduino的理解</h4><ul><li>arduino是一个开源的单片机平台，有很多版本，例如最常用的UNO板和nano板，都是基于AVR8位单片机的，属于最通用的单片机平台（无太多专用功能，全是通用I/O口），还有一些附带有专用功能的版本，例如esp8266开发板（非官方），可用于网络连接，还有很多其他的版本，详细版本间的比较可以参考：<a href="https://www.arduino.cc/en/Products/Compare" target="_blank" rel="noopener">arduino官网比较</a>。</li><li>有非常多的开源库，例如最基础的servo（用于控制伺服电机），softwareSerial（用于软串口通信），wire（用于IIC通信）等等。库列表可以参考官方库，开源项目可以参考：<a href="https://github.com/search?q=arduino" target="_blank" rel="noopener">github上的搜索结果</a></li><li>库的作用是，当我们在实现一个功能时，可以非常简单地调用api，而不是要配置各种寄存器（这是跟51等底层单片机最大的区别之一），因此arduino的编程大多数时候是<code>面向库编程</code>的，再加上各个库基本都提供了完善的使用案例，因此arduino的编程大多数时候也是<code>面向复制粘贴编程</code>，这大大降低了arduino的编程难度，因此，在学习arduino时，非常重要的两个过程：①寻找实现某功能的库，②读懂例程的逻辑。</li><li>当我们脑海中能建立起功能与库的对照表时，arduino就学会了45%了，当我们能熟练使用一些常用的库进行实践时，我们就学会了arduino的90%了。另外10%？当然还是要留给功能实现的源码的。在能使用库进行实践后，若想进一步深入学习嵌入式编程，当然还是要读一下源码，至少大致知道实现的逻辑，也能帮助自己提升对C语言（C++）的理解。</li><li>是否进入那个10%，就需要看自己的长期规划了，对于绝大多数人而言，是不需要非常深入地认识的，例如我。</li><li>我学习arduino的目的有三个，其一，认识物联网编程的特点，其二，实现一些有趣的功能，其三，培养编程的思维和一些习惯。因此，我不会再特别深入地去学习arduino库的实现方式，有这个时间的话，我会再去使用以下51，或者玩一下stm32做一些简单的实践，以及返回去学习c语言基础。</li></ul><h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><ul><li><p>这是一个基础的智能家居实现，将使用<code>arduino UNO r3</code>作为传感器的主控板，使用wifi模块连接家庭网关，将数据传输到服务器上，服务器将数据进行持久化，并使用web作为面板，可以查看传感器传回的一些数据，也可以控制电机的转动。</p></li><li><p>整个项目可以划分为几个小的部分，用于实现几个不同的场景，例如：①小车驱动的移动平台，可以实现在房间内移动。②上下楼移动平台，可以实现自动上下楼梯，并携带一定货物。③环境量收集，用于收集是否下雨，气温，光照，土壤湿度等，并上传至服务器存档，可用于控制灯光、水泵、风扇、空调（IR）等。</p></li></ul><h4 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h4><h5 id="移动平台的需求"><a href="#移动平台的需求" class="headerlink" title="移动平台的需求"></a>移动平台的需求</h5><ul><li>移动平台的基础是一个两轮小车的底盘，可以在房间内进行移动，以达到能够递送一些小东西的作用，具体而言，有如下功能需求：<ul><li>水平方向移动</li><li>蔽障</li><li>云台带超声波传感器</li><li>云台带智能终端手机</li><li>小车位置定位</li><li>携带少量物品</li><li>远程控制</li><li>移动调速</li><li>声音检测</li><li>感知人</li><li>信号传输</li></ul></li><li>还有一些更高级一些的功能需要思考，例如：<ul><li>语音识别</li><li>图像识别</li><li>视频采集</li></ul></li></ul><h4 id="需要的材料及软件"><a href="#需要的材料及软件" class="headerlink" title="需要的材料及软件"></a>需要的材料及软件</h4><ul><li>电子元件及材料：<ul><li><code>arduino UNO r3</code>作为主控板</li><li>两轮小车地盘作为移动平台</li><li>云台作为超声波模块和智能机的方向控制组件</li><li>人体感应模块作为人体运动检测传感器</li><li>声音输入模块作为声音检测（语音输入）传感器</li><li>充电宝作为能源模块</li><li>蓝牙（wifi）模块作为串口数据传输模块</li><li>小喇叭作为音频输出模块</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="各个模块功能测试"><a href="#各个模块功能测试" class="headerlink" title="各个模块功能测试"></a>各个模块功能测试</h5><h6 id="运动模块"><a href="#运动模块" class="headerlink" title="运动模块"></a>运动模块</h6><ul><li>使用两个直流电机，两轮小车底盘，L298N电机驱动模块，5v转9v升压模块升压，红米2WmAh充电宝供电。</li><li>电机带码盘，但暂时没有光电模块，因此采用人工初始调速校准。</li><li>电机驱动连接方式为IN1悬空，IN2接+5v，IN3接+5v，IN4悬空EN1接5，EN2接6。</li><li>上代码：<pre><code>int motoL = 5; //定义左轮胎针脚int motoR = 6; //定义右轮胎针脚int motoLs = 0; //定义左轮胎速度int motoRs = 0; //定义右轮胎速度</code></pre></li></ul><p>void setup() {<br>  // put your setup code here, to run once:<br>  Serial.begin(9600);<br>  pinMode(motoL,OUTPUT); //定义左轮胎针脚输出<br>  pinMode(motoR,OUTPUT); //定义右轮胎针脚输出(我总觉得这里的定义没多大用？)</p><p>  analogWrite(motoL,motoLs); //初始化左轮胎速度<br>  analogWrite(motoR,motoRs); //初始化右轮胎速度<br>}</p><p>void loop() {<br>  // put your main code here, to run repeatedly:<br>}</p><pre><code>###### 云台模块* 云台使用SG90作为舵机，旋转范围为0-180°，但买的这个舵机质量一般，0°没有在原位上，大概只能转动160°的样子。* 现在仅测试一个舵机（还有一个在路上），由于舵机仅需要一个数字I/O口，因此使用2号针脚。（3号针脚预留给垂直舵机）* 上代码：</code></pre><p>#include &lt;Servo.h&gt; //导入Servo库</p><p>int servoHrPin = 2; //定义servo的输出口<br>int servoHrPos = 90; //定义servo初始位置<br>Servo servoHr ; //创建servo实例水平舵机</p><p>void setup() {<br>  // put your setup code here, to run once:<br>  pinMode(servoHrPin,OUTPUT); //定义水平舵机针脚输出模式<br>  servoHr.attach(servoHrPin); //绑定水平舵机针脚<br>  servoHr.write(servoHrPos); //初始化水平舵机位置<br>}</p><p>void loop() {<br>  // put your main code here, to run repeatedly:<br>    for ( byte i = 0; i &lt;= 180; i += 10) {<br>        servoHr.write(i);<br>        delay(50);<br>    }<br>    for (byte i = 180; i &gt;=0; i -= 10){<br>        servoHr.write(i);<br>        delay(50);<br>    }<br>}</p><pre><code>###### 人体检测模块* 这个模块其实应该叫做“热源运动检测模块”，是通过检测红外释热变化输出一个数字信号。因此只有在固定状态下才能测出准确的数据，当模块本身是运动的时候，常出现误判。* 该模块仅用一个数字I/O，分配给7号针脚。* 上代码：</code></pre><p>byte peo = 7; //定义人体检测针脚<br>bool hasPeo = false; //定义是否有</p><p>void setup() {<br>  // put your setup code here, to run once:<br>  Serial.begin(9600);<br>  pinMode(peo,INPUT); //定义人体检测模块输入模式<br>}</p><p>void loop() {<br>  // put your main code here, to run repeatedly:<br>    hasPeo = digitalRead(peo); //进行人体检测值<br>    Serial.println(hasPeo); //检测输出<br>    delay(50);<br>}</p><pre><code>###### 声音检测模块* 我一开始买的套件的这个声音检测模块，仅能输出数字信号，也就意味着仅能判断是否有声音，已经重新购买能输出模拟量的声音输入模块，因此直接使用A0口作为信号接收口，同时，11口预留给声音输出模块。* 上代码：</code></pre><p>byte soundIn = A0; //定义声音输入针脚<br>bool hasSoundIn = false; //定义是否有声音输入</p><p>void setup() {<br>  // put your setup code here, to run once:<br>  Serial.begin(9600);  //设置串口波特率<br>  pinMode(soundIn, INPUT); //定义声音输入模式</p><p>}</p><p>void loop() {<br>  // put your main code here, to run repeatedly:<br>    hasSoundIn = digitalRead(soundIn); //进行声音检测<br>    Serial.println(hasSoundIn); //输出检测结果<br>    delay(50);<br>}</p><pre><code>###### 小喇叭模块* 使用小喇叭8欧0.5W的，使用PMW输出。* 分配针脚为10。* 一些比较详细的知识可以查看：[arduino+小喇叭制作简易歌曲](http://www.yfrobot.com/thread-2269-1-1.html)。* 上代码：</code></pre><p>byte playPin = 10; //定义小喇叭针脚<br>int tune[] = {};  //申明音调数组<br>float tunetime[] = {}; //申明音调时间数组</p><p>void setup() {<br>  // put your setup code here, to run once:<br>  pinMode(playPin,OUTPUT); //定义小喇叭的针脚为输出模式<br>  analogWrite(playPin,0); //初始化小喇叭为不输出状态<br>  int tune[] = {NOTE_G6,NOTE_GH1,NOTE_G7,NOTE_G6,NOTE_G5,NOTE_G6,NOTE_G3,<br>  NOTE_G6,NOTE_G5,NOTE_G6,NOTE_GH1,NOTE_G7,NOTE_GH1,NOTE_G7,NOTE_G6,NOTE_G7,<br>  NOTE_GH1,NOTE_GH1,NOTE_GH2,NOTE_GH3,NOTE_GH3,NOTE_GH3,NOTE_GH3,NOTE_GH2,<br>  NOTE_GH1,NOTE_G7,NOTE_G6,NOTE_G7,NOTE_G5,NOTE_G6,NOTE_GH1,NOTE_G7,NOTE_G6,<br>  NOTE_G5,NOTE_G6,NOTE_G0,NOTE_G0,NOTE_G0,NOTE_G0,NOTE_G0}; //案例音调<br>  float duration[]={1200,800,400,400,400,400,2400,400,400,1200,400,400,200,<br>  200,400,400,2400,400,400,400,400,400,400,1600,400,400,400,400,1600,800,800,<br>  800,400,400,2400,800,800,800,800,800}; //案例时长<br>  int tuneNo = sizeof(tune)/sizeof(tune[0]); //获得音调数组长度<br>  int tuneTiNo = sizeof(duration)/sizeof(duration[0]); //获得时长数组长度<br>  play(playPin,tune,duration,tuneNo); //播放音乐<br>  Serial.println(sizeof(tune)/sizeof(tune[0]));<br>  Serial.println(sizeof(duration)/sizeof(duration[0]));<br>}<br>void loop() {<br>  // put your main code here, to run repeatedly:<br>}<br>void play(int playPin,int *tune,float *tunetime,int tuneNo){ //定义播放函数<br>  for(int i = 0; i &lt; tuneNo; i++){<br>    tone(playPin,tune[i]);<br>    Serial.println(tune[i]);<br>    delay(tunetime[i]);<br>  }<br>  noTone(playPin);<br>  return ;<br>}</p><pre><code>###### 温度模块* 温度传感器使用的是DS18B20，该温度传感器需要连接10k电阻才能使用，(-｡-;)回头再做这个吧###### 超声测距模块* 超声测距模块需要有两个IO口，一个用于发送一个trigger信号用于检测，另一个用于接收超声波模块传回的信号。* 该模块返回的为高电平信号，电平的时长即时模块从发出超声波到接收到超声波的时长，声音在空气中传播速度为340米每秒，假设接收到的市场为t豪秒，则两者的距离d=0.017t，换个形式，d=t/58（约等于）。* trigger应当要输出至少10us的高电平用于触发，分配针脚9。* echo分配10。* 上代码：</code></pre><p>byte disEcho = 8; //定义超声接收针脚<br>byte disTri = 9;  //定义超声触发针脚<br>float distance ;  //定义距离</p><p>void setup() {<br>  pinMode(disEcho,INPUT); //定义distance信号接收输入模式<br>  pinMode(disTri,OUTPUT); //定义distance触发信号输出模式<br>  digitalWrite(disTri,LOW); //初始化trigger为低电平<br>}</p><p>void loop() {<br>  // put your main code here, to run repeatedly:<br>  distance = dis();<br>  Serial.println(distance);<br>  delay(100);<br>}</p><p>float dis(){ //定义测量距离的函数<br>  digitalWrite(disTri,LOW); //保证初始值无误<br>  delayMicroseconds(2);<br>  digitalWrite(disTri,HIGH); //触发超声测距<br>  delayMicroseconds(13);<br>  digitalWrite(disTri,LOW); //关闭触发<br>  return pulseIn(disEcho,HIGH)/58.0; //返回距离<br>}</p><pre><code>#### 逻辑总结（详见9.2日学习记录）* 仅仅是最基础的代码和组件其实意义不是特别大，因为arduino的库非常丰富，简单的传感器的使用也非常简单。### 通信方式#### 蓝牙通信方式* 先只用蓝牙进行通信，第一阶段调试时用蓝牙调试工具进行调试。第二阶段使用AI2自行设计app进行操作。* 蓝牙的使用相对wifi更为简单，指令也比较少，采用HC-05主从一体蓝牙模块（14元），串口通信没有进行软串口操作，直接使用Pin0和Pin1进行串口通信，也没有修改默认密码，因此未操作AT指令。（AT指令部分还是应当做一下试验，改改密码什么的）* 蓝牙采用4位pin码，因此安全性相对较弱，暴力破解起来非常简单，数据传输也是直接使用明文传输，信号拦截也不是很难。（去了解蓝牙加密内容，蓝牙防破解等）。因此，在进行蓝牙传输时，最好先使用加密算法一定程度的加密，然后再进行传输，收到串口数据时，也应当用加密后的密文进行传输。* 通信过程中，最主要的工作是进行信息预处理，得到能够被识别的指令，以及进行数据传输的格式约定，通常的设备进行数据交换时，多采用JSON的数据格式，但是对于工作内容非常简单的单片机而言，JSON数据相对复杂，解析不大方便。很多人直接使用HEX格式进行通信（甚至电视空调等IR控制也是使用HEX进行通信）。* 我的这个项目先使用HEX进行通信，用于实现以下简单的指令，以及数量不多的传感器数据上传。在弄清楚HEX数据交换的使用之后，再去考虑json的实现（有现成的库，也可以尝试自己写解析函数）。* 总结能够输入的指令和要输出的数据：    - 输入的指令：        + 小车左转`指令+转弯速度``1001+01`        + 小车右转`指令+转弯速度``1001+02`        + 小车速度`指令+速度``1011+0~100`        + 小车停下`指令``1012`        + 舵机hr转动`指令+角度``1101+0.0-180.0`        + 舵机ve转动`指令+角度``1102+0.0-180.0`        + 超声测量距离`指令``1201`        + 超声雷达模式`指令+角度范围``1202+0.0+180.0+0.0+180.0`        + 小车播放指定声音`指令+指定声音``1301+0~5`        + 小车播放传入声音`指令+传入声音``1302+0~7(调)+[](音调)+[](节拍)`        + 小车打开/关闭灯光`指令+状态``1401+0~F`        + 小车检测是否有人`指令``1501`        + 小车检测是否有声音`指令``1601`        + 小车检测环境温度`指令``1701`        + 小车检测环境光照`指令``1801`        + 小车检测灯光状态`指令``1901`        + 小车初始化状态`指令``2001`        + 小车进入休眠模式`指令``2101`        + 小车唤醒`指令``2501`    - 输出的数据：        + 小车附近是否有声音`特征值+结论``1601/1602`        + 小车附近是否有人活动`特征值+结论``1501/1502`        + 小车附近温度如何`特征值+结论``1701+-20~140`        + 小车附近光照如何`特征值+结论``1801+xxx`        + 小车某方向上物体的具体距离`特征值+距离``1201/1202/1203...(指定角度)+4.0~xxxx.x`        + 小车的运动状态（加装陀螺仪）`特征值+状态``0A01+xxx`* 用符号`;`分割不同指令，用`:`分割单一指令的不同参数。#### 总结展望* 整个语音部分可以进行拓展，现阶段存在一些不容易解决的问题：    - 语音输入，要能够接收模拟量，并将接收到的数据发送到互联网上，进行语音识别，并根据识别的内容返回一定指令，用于控制物联网设备。    - 音频输出，要能够对WMA或MP3进行抽帧解码，并进行播放，这样可以将一些音频存放于服务器中，由arduino进行访问调用。* 在控制逻辑上还需要进行细化，很多能进行函数封装的要进行封装，进而使得代码清晰简洁。先使用蓝牙作为控制工具，用手机进行控制调试，再用wifi进行调试。* 小喇叭模块，在定义音调和时长时，还可以进行更加简洁地定义方式，C调D调等之间有错1位的关系，调子可以直接写成D1-D7，DH1-DH7，DL1-DL7三个音阶，时长可以直接用拍子数定义，1=1拍=800ms，0.5=半拍=400ms，0.25=1/4拍=200ms，0.125=1/8拍=100ms，2=2拍=1600ms，3=3拍=2400拍。（或者按照四分音符为一拍，直接输入4为四分音符，8为8分音符，16为16分音符，2为二分音符，1为全音符。（时长为4*1/n*800ms））。* 外部中断在现在的程序中还没有使用，低功耗模式，看门狗唤醒等功能也都未使用，应当在后续完善时添加上。参考资料：[Arduino看门狗的使用方法](https://blog.csdn.net/killerstranger/article/details/79902957)、[重要资料](http://gammon.com.au/power)、[台湾IOT论坛文章](https://swf.com.tw/?p=525)、[定时中断的实现](https://blog.csdn.net/LCtesla/article/details/80555480)、[外部中断和定时器中断](https://blog.csdn.net/qq_39591322/article/details/89155079)。* 在进行数据处理或进行逻辑处理时，位操作的效率会比十进制操作的效率高很多，因此要学习位操作的方式以及其特点。位操作具体还有些什么优点我也不是很清楚，需要继续查一下。&lt;hr /&gt;## 一些问题### 数组传值问题* 在定义函数需要把数组作为参数传入时，传入的其实是数组的第一个值的地址，因此若在数组内用sizeof()/sizeof()，得到的是1。要遍历数组的值，需要多传入一个参数“数组的长度”，可以在参数传入时用sizeof()进行运算得到。* 数组传参传传的是地址，因此可以用数组名，可以用指针，在函数内，根据参数的形式，可以直接用参数名，也可以用取地址符。### tune()函数的问题* arduino自带的这个函数，其实质也是一个使用类似于delay()和analogWrite()产生的不同频率的方波，用高频来模拟正余弦波，所以会占用arduino的时钟，也就意味着在播放音频时，是无法进行其他运算的。也就是说，这是一个阻塞的函数。* 是否可以通过简单的外部扩展，使得可以在播放声音的时候同时执行其他内容？## 一些想法* 除了技术实现以外，在智能家居或者物联网中，我认为有两个方面的能力或知识特别重要，其一，是能根据项目的现实条件，规划特定的设备、协议、元件等，达到整体最低成本（综合考虑开发成本、维护成本、再开发成本等）。其二，是能总结需求，能够从人们的需求角度出发，设计对应的物联网产品，并能在市场上了解到类似物联网产品的优劣势以及产生原因。这两方面，前者需要对物联网开发的框架、技术栈等有非常丰富的了解，后者可以通过专门的分析和比较，自行总结出需求，再加上实践经验等。由于我现在两方面均不具备，所以要达到非常专业的物联网开发水平还是有很长的路要走的，不过现在我可以先从分析现有产品所满足的需求角度，总结一波，然后可以再畅想一波。* 可用于尝试的项目：①智能垃圾桶；②智能厨房；③智能上下楼搬运；④智能浇水机；⑤智能农场；⑥智能安防。</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络知识+arduino思考</title>
    <link href="undefined2019/08/29/arduino+%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%861/"/>
    <url>2019/08/29/arduino+%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%861/</url>
    
    <content type="html"><![CDATA[<h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><ul><li>防火墙和网关和路由器和交换机的区别：<code>防火墙（firewall）</code>最基础，就是简单的是否允许ip包通过的一个机制，因此应当作为最外层安全防御；<code>网关（gateway）</code>是一个功能跟复杂和全面的安全机制，网关本身是运行着操作系统的，因此可以接收所有网路传输过来的数据，并能够进行解析，因此能够做更多深层次的数据过滤；<code>路由器（router）</code>本身功能比较基础，就是用于数据转发，可以给连入设备分配ip，因此可以用于组建局域网；还有一个概念<code>交换机（switch）</code>，用于拓展网口，做数据分发，可以简单理解成拓展坞。虽然四者从概念上有区分，但生活中，我们基本都叫路由器，因为我们购买的路由器都涵盖了上述四个功能，但是我们对防火墙和网关的直观印象比较弱，而对“路由”功能印象更直观，所以常说的家用路由器，功能基本都是涵盖的。在专业的网络搭建中，功能更加分化，因此会分化出不同的物理机，不同的机器做专业的事情。<ul><li>补充一个<code>调制解调器（Mordem）</code>是一个物理层的设备，在往年用电话线拨号时，它的作用是将电话线传来的模拟信号转化成计算机能够识别的数字信号（或相反），这些年使用光纤后，它的作用是把光纤传来的光信号转化成计算机能够识别的数字电信号（或相反）。</li><li>再补充一个<code>集线器（Hub）</code>，可以理解成一个低配版的路由器和交换机的杂交种吧，具有多端口，可以用作拓展设备网口，也能够全局广播，建立连接后进行数据转发。</li></ul></li></ul><h2 id="我的尝试"><a href="#我的尝试" class="headerlink" title="我的尝试"></a>我的尝试</h2><h3 id="arduino项目"><a href="#arduino项目" class="headerlink" title="arduino项目"></a>arduino项目</h3><h4 id="对arduino的理解"><a href="#对arduino的理解" class="headerlink" title="对arduino的理解"></a>对arduino的理解</h4><ul><li>arduino是一个开源的单片机平台，有很多版本，例如最常用的UNO板和nano板，都是基于AVR8位单片机的，属于最通用的单片机平台（无太多专用功能，全是通用I/O口），还有一些附带有专用功能的版本，例如esp8266开发板（非官方），可用于网络连接，还有很多其他的版本，详细版本间的比较可以参考：<a href="https://www.arduino.cc/en/Products/Compare" target="_blank" rel="noopener">arduino官网比较</a>。</li><li>有非常多的开源库，例如最基础的servo（用于控制伺服电机），softwareSerial（用于软串口通信），wire（用于IIC通信）等等。库列表可以参考官方库，开源项目可以参考：<a href="https://github.com/search?q=arduino" target="_blank" rel="noopener">github上的搜索结果</a></li><li>库的作用是，当我们在实现一个功能时，可以非常简单地调用api，而不是要配置各种寄存器（这是跟51等底层单片机最大的区别之一），因此arduino的编程大多数时候是<code>面向库编程</code>的，再加上各个库基本都提供了完善的使用案例，因此arduino的编程大多数时候也是<code>面向复制粘贴编程</code>，这大大降低了arduino的编程难度，因此，在学习arduino时，非常重要的两个过程：①寻找实现某功能的库，②读懂例程的逻辑。</li><li>当我们脑海中能建立起功能与库的对照表时，arduino就学会了45%了，当我们能熟练使用一些常用的库进行实践时，我们就学会了arduino的90%了。另外10%？当然还是要留给功能实现的源码的。在能使用库进行实践后，若想进一步深入学习嵌入式编程，当然还是要读一下源码，至少大致知道实现的逻辑，也能帮助自己提升对C语言（C++）的理解。</li><li>是否进入那个10%，就需要看自己的长期规划了，对于绝大多数人而言，是不需要非常深入地认识的，例如我。</li><li>我学习arduino的目的有三个，其一，认识物联网编程的特点，其二，实现一些有趣的功能，其三，培养编程的思维和一些习惯。因此，我不会再特别深入地去学习arduino库的实现方式，有这个时间的话，我会再去使用以下51，或者玩一下stm32做一些简单的实践，以及返回去学习c语言基础。</li></ul><h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><ul><li>这是一个基础的智能家居实现，将使用<code>arduino UNO r3</code>作为传感器的主控板，使用wifi模块连接家庭网关，将数据传输到服务器上，服务器将数据进行持久化，并使用web作为面板，可以查看传感器传回的一些数据，也可以控制电机的转动。</li><li>整个项目</li></ul><h4 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h4><h4 id="需要的材料及软件"><a href="#需要的材料及软件" class="headerlink" title="需要的材料及软件"></a>需要的材料及软件</h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><h4 id="总结展望"><a href="#总结展望" class="headerlink" title="总结展望"></a>总结展望</h4><hr>## 一些问题<ul><li>学习痛苦的根源在于两个方面：①不知道自己要学啥。②不知道自己在学的是啥。要解决这两个问题，首先要保持一个习惯：先从宏观上了解（甚至是熟悉）所学内容的框架，再根据框架的要求去学习细节知识。其次，要给自己制定一些清晰的小目标，小目标能让自己不忘记现在在做什么，例如“今天学习ai的使用，并写一篇博客总结自己的理解”“今天设计出自己的arduino的demo程序框架，并用代码实现，同时写一篇博客”，其实也可以说是“成果管理”。</li><li>小目标很容易制定，因为成本小，见效快，就算失败也能承受，但是大目标却很难制定，因为不确定的因素太多了，我们很容易避而不谈大的目标。虽然直面这个问题很痛苦，但是还是应当要面对这个问题，因为人无远虑必有近忧，该来的问题总会来的，我也应当要正面这个问题才是。今天内，写一个思考的博客。</li></ul><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><ul><li>学习arduino的路径，应当从三个方面进行。其一，应当学习物联网编程的一些框架和环境，例如以c语言或c++为编程语言，使用keil或arduino为IDE，使用串口通信较为常见，需要先烧录再运行，flash等资源较少，使用很多的传感器进行数据收集（例如光电、压电、声音、超声、温度、湿度、加速度等），使用很多执行器进行交互（例如继电器、servo、motor、灯光、数码管、点阵、LCD等等），同时还有一些用于通信（例如串口txrx（蓝牙、wifi、lora、gprs等）、外部寄存器（串入并出等等）），要熟悉物联网编程的协议（例如http、mqtt），以及服务器端api的创建，还有客户端的创建（web或app或微信小程序），三个层级的数据交互方式（通信方式、数据格式等）。</li><li>其二，要训练编程思维，如何拆解程序成各个模块，各个模块中应当先用什么语句再用什么语句，使用外部库时应当有些什么注意事项。这部分十分重要，这不仅是对物联网编程有意义，对其他的任何编程都非常有价值，这其实就是搞清楚程序是怎样一步步实现的。因此要多从思路方面进行思考，先想清楚应该要怎样做，模型是怎样的，可以采用阅读他人某功能的代码时做一些批注，自己写的代码也同样做很多批注，还可以采用一些图形化的编程工具，帮助从宏观上认识编程的各个模块都有些什么作用，而不是陷入细节陷阱中去。</li><li>其三，要熟练编程的各个细节，例如熟悉语言的规范（要在编程过程中不断去规范自己的写法，不断去总结语言的特性），要熟练使用一些非常常用的库（要先明白这些库的应用场景，再熟练使用这些库的api，最后再思考库的实现方式，可以的话，阅读源码），要熟练处理遇到的问题，例如在写代码过程中遇到了问题该如何去处理，陷入思路阻塞应该怎么办，心情烦躁该怎么办。</li><li>【项目思考】由于人的记忆力有限（尤其是我这种金鱼人），经常不记得自己当天做过什么，完成了哪些事情，还需要完成那些事情，将来还要做什么事情，因此一个todolist是非常重要的，现阶段也有大量的todolist的工具，例如最基础的每日用<code>记事本</code>写下要做的事，做完就删掉，这在做一些非常细节且杂乱的事情时可以使用，做一项细节时可以使用，再例如用<code>便签</code>功能，也可以提醒我们还有些啥要做。如果想要跨平台使用，可以使用一些商用软件，例如<code>teambition</code>、<code>trello</code>，<code>滴答清单</code>，前两者都是跨国的，使用起来也非常不错。但是嘞，这些平台虽然都非常完善，前两者用于项目管理，后者用于日常清单管理都非常不错，但是对于我个人而言，还是有些缺憾，我希望我做过的事情能够有比较完善地被记录和统计，例如今天在“学习”上花了12个小时，在“arduino”上花了5个小时，中午做了“土豆胡萝卜腊肠焖饭”用时20分钟，这些统计便于我分析自己的时间是如何使用的，在做一件事的效率上有哪些地方值得改进，以及自己“做过哪些有趣的事”。我应当给自己平常做的事情划分一个标准，做的哪些事属于什么范围，例如“学习”–“js”“arduino”“linux”“raspi”“front-end”“accounting”“auditing”，“生活”–“做饭”“运动”等等。这可以做为一个项目，一个web的项目，平常可以用于制定计划，一段时间可以用于分析计划完成情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arduino学习记录</title>
    <link href="undefined2019/08/28/arduino%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <url>2019/08/28/arduino%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<h2 id="一些尝试"><a href="#一些尝试" class="headerlink" title="一些尝试"></a>一些尝试</h2><ul><li>在windows上安装了EMQX，据介绍，这是一个供物联网设备连接传输数据的面板，具体还有些什么功能，需要进行进一步的挖掘，参考资料：<a href="https://github.com/emqx/emqx/blob/master/README-CN.md" target="_blank" rel="noopener">官方github</a>。</li><li>有时候要对服务器的性能进行一些监控，尤其是linux系统的监控，这时可以使用linux-dash这个开源项目，有各个平台的版本（php、node、go），同时发现一个叫做hostmonitor的软件，据介绍可以实现一些比较深度的系统监控，主要是用于运维的检查等等，也可以远程查看，可以试着用一下。在树莓派上使用了一下linux-dash，用起来还不错，可以看一些基础的数据。除了linux-dash，还有一个名气比较大的宝塔面板，安装比较慢啊，用一下试试。参考资料：<a href="https://blog.csdn.net/IMW_MG/article/details/77823573" target="_blank" rel="noopener">在树莓派上安装宝塔面板你</a>、<a href="https://blog.csdn.net/freeking101/article/details/80574847" target="_blank" rel="noopener">好用的windows/linux面板工具</a>。我擦，宝塔面板非常好用啊！</li><li>用树莓派做的远程监控。树莓派自带的有vlc，也带有摄像头插孔，因此直接买了一个便宜的树莓派兼容摄像头（16元左右），用vlc推流到本地端口，再用ssh转发到远程服务器端口，然后再手机上通过vlc就可以进行查看了。由于我国内的服务器是windows系统的，所以还安装了一个freessh的软件，用于在windows下搭建sshd。由于freessh的官方文档没读大懂，因此在配置public—key登录的时候费了很多事，需要注意。之后还要租服务器的话，一定要装linux系统的。虽然这样也能看，但其实不是特别好，本地除了使用vlc推流，还可以使用一些其他的工具，例如motion，可以直接用配置文件来配置，比vlc的命令行简单多了。在内网穿透上，使用ssh直接转发相对来说比较简陋，可以使用那个frp等工具来进行ssh转发的配置，稳定性要高一些。还有播放模式的问题，直接把监控视频源暴露在公网上可以说是非常不安全了，应当有一层密码，最好是能通过页面访问。可以使用mjpg-streamer作为获取摄像头数据并转发的工具（关键是！这个库还能支持openwrt！！是不是意味着路由器就可以插个摄像头搞起来？），可以玩一玩。参考资料：<a href="https://www.jianshu.com/p/c355dc1961b0" target="_blank" rel="noopener">在线视频监控mjpg-streamer</a>、<a href="https://blog.csdn.net/qq_41923622/article/details/88366185" target="_blank" rel="noopener">树莓派 USB摄像头 实现网络监控（ MJPG-Streamer）</a></li></ul><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><ul><li>使用linux登录微信的方法，在python环境下可以使用“itchat”或者“wxpy”这两个库，在node环境下可以使用“wechaty”库。可以用来做微信机器人，或者说可以用来传送命令，用于控制家中的一些设备。</li><li>为什么要使用微信作为传送命令的媒介呢？主要有两个层面的优势，其一，我们平常使用微信非常频繁，那么在给远程设备发送消息时，用微信也可以免于再打开其他app或网页来得方便。其二，就安全性来说，微信的安全防护措施比我们自己搭建的公网服务器安全措施应当是强很多了，所以大多数情况下，相信微信的安全性还是可以得。其三，转发消息始终需要公网，要不就是自己搭建云端服务器，要不就是使用现成的一些物联网云服务，例如机智云、阿里云物联网、aws等等，简单的一些指令还行，若是数据量比较大，还是比较麻烦的。其四，我了解这方面内容是由于有在安卓机上做微信消息转发的需求，因为安卓机的各方面设备十分齐全，尤其是通信速度和稳定性都非常高，用安卓机做一些家用的小机器人的项目，薅一薅微信的羊毛还是非常省成本的（例如微信视频通话）。</li><li>由于之前购买阿里云的服务器时，安装的是windows系统，但由于windows系统下很多问题都比较奇怪，网上关于windows下安装一些应用的坑都没有教程，因此踩了坑得自己去爬起来，十分痛苦，虽然一开始上手容易，但对于将来的发展来说，是没有太多益处的，这台服务器到期后，国内的服务器是否还要续租就得再考虑了，就算有便宜的服务器可以租，也一定要采用linux系统的。</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul><li>arduino作为一个单片机开发板，有两方面的主要作用，其一是“输入传感器发送回来的电平信号”，其二是“给传感器发送电平信号”，这仅仅是针对单片机与传感器的通信，通过I/O口直接发送信号。若要使arduino与其他设备进行通信，则需要使用其他的通信方式，也就是远程通信，最简单的方式有蓝牙通信（ble，12元左右），以及有wifi通信（例如esp8266，9元左右），但这两者的传输距离都非常受限，在近距离（10米内，且无大的阻碍）通信时可用，例如家庭内，尤其是使用网关的，一定要保证信号覆盖全面（使用2.4G信号较好，或者在周边添加信号增强），若是距离再远一些，使用lora传输，可达几百米。（其实wifi也可以达到几百米，需要增加信号放大以及定向，蓝牙在空旷环境下可以达到几十米至一百米），因此，在智能农场等环境下，就可以使用wifi作为场地内通信方式，使用lora作为场地与基地的通信方式（更远则需要使用中继或者直接使用gprs通信，这两者成本都不低。）。可参考文章：<a href="https://blog.csdn.net/lihongzhai/article/details/80381554" target="_blank" rel="noopener">连接到物联网的12种方式</a>。</li><li>物联网的服务器端配置，可以采用EMQ的dashboard，在网上见到有人使用，对各种协议的支持都不错，尤其是MQTT的通信，应当再学习一下该平台有什么用。</li><li>定位系统的使用，之前看到有人使用traccar做定位系统（包含服务器端可客户端，都是开源的），但我自己试用没有配置成功，客户端相对比较简单，通过wireshark抓包能看到数据已经传送到服务器上，传送的也确实是经过编码后的位置信息，但是服务器端在面板上解析不出来位置，而且地图的显示非常非常慢，百度地图还无法显示，不知道是哪里出了问题，可以再分析一下，实在不行，就换一下开源系统。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodered学习记录</title>
    <link href="undefined2019/08/13/nodered%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <url>2019/08/13/nodered%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<h1 id="nodered学习记录"><a href="#nodered学习记录" class="headerlink" title="nodered学习记录"></a>nodered学习记录</h1><h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><ul><li>智能设备与服务器进行通信，有两个方向：①单片机向服务器发送数据；②服务器向单片机发送数据。因此至少有两种通信的方式。<ul><li>①单片机向服务器：直接采用socket发送数据，并使用心跳检测机制维持连接，可以将传感器的数据发送到服务器。</li><li>②服务器向单片机：由单片机定时向服务器请求数据，服务器将需要传输的指令存放在某个文件内，在单片机向服务器请求数据时传回。</li><li>③另一种思路：采用长链接？(还不是很懂)</li><li>④再一种思路：采用ssh连接，形成反向隧道，服务器直接将数据发送到某个端口就行，单片机端也直接将数据发送到某个端口。</li></ul></li></ul><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><ul><li>先做个小项目尝试一下数据传输的功能。（已完成，~/shtest/test.sh，47.93.218.209:93）<ul><li>尝试了在linux下的shell编程，讲真，非常好用。</li><li>用了crontab的命令，用于定时执行命令，用来实现心跳机制还是不错的。</li><li>服务器端使用了php作为数据承接入口，返回的数据使用date()函数，以及使用linux下的date命令，产生日志文件名以及文件内标签。</li><li>服务端可以采用更加高级的结构，以便做更多复杂的事情，之后的数据需要存储在mysql数据库中，php也应当用框架来承接业务逻辑。</li><li>在使用shell编程时，接收到的json在shell下可以直接用jq工具<code>cat xxx | jq</code>显示出来。</li><li>在打印日志的时候，可以先通过一个函数对接收的数据进行判断，用以分割需要存储为日志的部分和不需要存储的部分。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>nodered</tag>
      
      <tag>raspi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js学习记录-阮一峰教程</title>
    <link href="undefined2019/08/05/js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E9%98%AE%E4%B8%80%E5%B3%B0%E6%95%99%E7%A8%8B/"/>
    <url>2019/08/05/js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E9%98%AE%E4%B8%80%E5%B3%B0%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><ul><li>ES6有6种声明方式： var function let const import class，这在ES5中只有前两种</li><li>ES5中没有块级变量（仅有全局变量和func变量），且所有声明都会被hoisting，因此可能会出现变量污染的情况，在ES6中增加了块级变量（包括函数），因此在{}内进行变量声明，就只能在块内使用。</li><li>浏览器的顶层对象是window，因此全局变量可以使用window.xx，node环境下，顶层对象是global，声明全局变量可以在除了func内使用var就行，要使用全局对象，可以使用global。在浏览器中也可以使用self关键词。为了保持通用性，一般使用this表示全局对象。</li><li>this在全局环境中，返回顶层对象，在模块中，this返回当前模块，在构造函数中（let xx = new func(){this.xxx = xxx;}），this指向新构造的对象；内建函数（例如settimeout）中，this指向顶层对象；在箭头函数中，没有this，因此，当使用this时，会向上一级作用域寻找this。在call和apply函数中，this指向第一个参数。<a href="https://blog.csdn.net/weixin_37722222/article/details/81625826" target="_blank" rel="noopener">this的指向总结</a></li><li>解构，可以批量赋值，使用可遍历的数据类型（数组、构造函数），用于解构数组和对象，数组是按照排序依次赋值，而对象没有顺序，因此是按照key值进行赋值。</li><li>对象结构可以重新定义名称，{foo:foo} = {xxx}，这样的形式，因此也可以{foo:name} = {xxx}，前面的foo是用于匹配模式，匹配后面对象的键值，name才是真正被赋值的变量。</li><li>在结构赋值的情况下，括号不能乱用，不然会导致无法识别结构赋值模式，总结来说，两种情况下不能使用括号，模式识别、变量申明，因此在有let的情况下不能使用括号，在function的参数中不能使用括号，不能包裹<code>：</code>符号。</li><li>```用这个符号包裹的内容可以用${}来在字符串中混合js变量以及运算语句，也可以直接接在函数名后，执行后的值作为参数。执行时，先将所有非${xx}的内容转变成数组，且以${xx}为分割，每个${xx}都是一个新的参数。</li><li>在函数中使用参数解构时，不能完全省略传入的参数，即使只传入{}空对象也行，例如， function(x,y=1){xx}，就可以只传入{}，结构时，未找到x，则自动生成一个x = undefined。 可以给整个对象参数赋值一个默认空对象就能避免上述的错误，function({x,y=1}={}){xx}。</li><li>箭头函数的函数体部分，如果只是返回一个对象，则需要加()，否则会被解析成一个代码块，从而报错。</li><li>箭头函数中，没有this、super、arguments、new.target这些关键词，因此也不能使用call、apply、bind的方法改变this的指向，在箭头函数中使用这些方法时，this依然指向上层对象。因此在对象的箭头函数中，不能使用this来试图代指对象内的其他键值，此时this指向的是全局对象。</li><li>由于箭头函数中没有this，因此不能用于构造函数，也不能用于动态使用this的监听事件执行的函数，例如 getElementById(“XX”).addEventLinstener(“click”,()=&gt;{this.classList.toggle(“on”)})，此处的this会指向全局对象。</li><li>拓展运算符，<code>...</code>，类似于rest的逆运算，将一个数组转变成用逗号分隔的参数序列，因此在传参时非常好用，将所有需要的参数放入数组，再使用拓展运算符，就能把所有参数依次放入。</li><li>在使用拓展运算符传参时，不能用括号包裹拓展运算符，会导致解析参数无法错误。</li><li>在ES5中，没有拓展运算符，而是使用apply来实现将数组变成参数传入，例如<code>fn(a,b,c){zzz}; aa=[1,2,3]; fn().apply(null,aa);</code>，这里apply的作用只是将aa从数组转变成参数列表，同样apply可以改变this指向，第一个参数即为this指向的对象（null的位置是this），也可以是一个函数，后面的为该函数的参数。</li><li>apply与call的区别在于，前者的参数使用数组形式，后者的参数使用参数列表形式，例如<code>fn(a,b,c){zzz}; fx().apply(fn,[a,b,c]); fx().call(fn,a,b,c);</code>。</li><li>在定义对象时，用<code>[]</code>可以用于执行表达式，也就意味着可以用一些字面量去给key命名，也可以用于给函数命名，例如：<code>let name = &quot;test&quot;;[name](){xxx};</code>在ES6中，对象中定义函数可以用简单的方式，<code>test(){xxx}</code>，或者直接用箭头函数<code>test = ()=&gt;{xxx}</code>，而不再需要使用<code>test : function(){xxx}</code>。</li><li>需要注意的是，在使用<code>[]</code>给对象中的属性命名时，也就意味着这就是一个属性名，而不再是对象的简单定义<code>{nameValue}</code>，而不能使用<code>{[nameValue]}</code>来表示<code>{[nameValue]:nameValue}</code>。并且，<code>[]</code>中所引用的变量或者表达式不能是对象，否则将转变成<code>[object Object]</code>。</li></ul><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>iterator的实现过程中，next()是如何取到nextindex++的？（闭包的实现方法和原理？在内存中的形式？）</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
      <tag>规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习记录-要做的项目</title>
    <link href="undefined2019/08/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%A6%81%E5%81%9A%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <url>2019/08/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%A6%81%E5%81%9A%E7%9A%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="js学习记录"><a href="#js学习记录" class="headerlink" title="js学习记录"></a>js学习记录</h1><h2 id="学习的内容"><a href="#学习的内容" class="headerlink" title="学习的内容"></a>学习的内容</h2><ul><li>既然是要学习web前端，那么从工作内容上来说，就是写各种网页，实现各种效果，跟后端进行各种数据交互，不论是简单的只管前端页面跳转，还是稍微复杂一点的前端路由页面内跳转，说到底，都是写网页。</li><li>学习一门技术，最基础的自然是理解其原理，能够在自己的领域内用自己的话把技术的原理说清楚；同时，从实践的角度出发，我们学习一门技术的目的，是为了解决某个问题，或者说，是为了更高效地解决某个问题，因此，学习的一大目标，就是提高使用该技术的效率，能够非常快地运用这门，所以，练习、总结、内化，这才是在学习时要做的事情。</li><li>综上两个观点，在学习web前端的技术时，要大量地模仿，模仿n多站点，达到能够非常熟练地使用不同的技术，以实现网站的功能，只有在大量的实践时候，才会发现自己的不足之处。</li></ul><h2 id="要做的事情"><a href="#要做的事情" class="headerlink" title="要做的事情"></a>要做的事情</h2><ul><li><p>把B站的站点做成完整站点，包括后台数据交互（使用php做后台）。</p><ul><li>前端使用ajax进行数据交互，把几个mode改成template的形式，template框架再选。</li></ul></li><li><p>把网易云课堂站点的三个页面全部写出来，并使用nodejs做后台实现部分数据交互。<em>【前端页面完成80%】</em></p><ul><li>原计划把index、course、category三个页面都做出来，但是category页面真的是太水了，几乎全是cou组件组成的，没有太大的价值，暂时不做。</li><li>数据的话，用爬虫爬取部分数据吧，本来东西也不多。</li><li>nodejs+mysql作为后台web服务器和数据库。</li><li>趁这个机会，把SQL系统性复习一下。</li></ul></li><li><p>快速模仿3个站点（争取一天做到3个站点的元素）。</p><ul><li>向物（直接写组件，自己封装简单的组件加载器）</li><li>知乎首页 （用template来写，并使用路由做SPA，后台使用IIS+php的方式）</li><li>玩物志（使用template，做单页，注重对登录、添加购物车、打包订单的逻辑）</li><li>一条官网（使用vue+router+axios+vuex+node+mysql完美实现还原）{做移动端适配}</li><li>唯品会首页（使用jq+template，着重于组件的实现以及布局的准确）</li><li>网易云音乐（用vue+router+axios来写）（什么页面用vuex能体现价值？）（做native app适配）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期学习规划-时间与内容</title>
    <link href="undefined2019/08/04/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"/>
    <url>2019/08/04/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="学习规划"><a href="#学习规划" class="headerlink" title="学习规划"></a>学习规划</h1><pre><code>从今天起，就要开始我的疯狂学习计划了，做好时间上的安排，把每个小时甚至每十分钟都利用起来，提高学习的效率，加强学习能力，把技术类知识补上。</code></pre><p>##　学习内容</p><pre><code>* web前端的各种技术，例如 JS、vue、element、bootstrap、jquery* 模仿站点，至少模仿4个站点* 自建站点，把博客页面搭建起来，并写学习博客，发表在csdn上和自己的博客系统上。* 对学习的每门技术，都要做学习总结，并写成博客。* 每天都要写学习规划和总结日记，整理每天的思路，并总结每天的学习成果。* web后端的部分技术，例如 Mysql、php、node。</code></pre><h2 id="学习时间规划"><a href="#学习时间规划" class="headerlink" title="学习时间规划"></a>学习时间规划</h2><pre><code>* 起床 6：30* 开始学习时间 8：00* 每日持续学习时间 12小时</code></pre><h2 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h2><pre><code>* 用电脑进行web前端知识和后端知识的学习。* 用树莓派进行linux下服务器端的一些知识学习。* 用实体纸张进行一些原型设计和总结。</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习vue的知识记录</title>
    <link href="undefined2019/08/03/vue%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    <url>2019/08/03/vue%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="学习vue的一些过程"><a href="#学习vue的一些过程" class="headerlink" title="学习vue的一些过程"></a>学习vue的一些过程</h2><ul><li>vue的webpack文件结构是怎样的？<ul><li>基础的文件有 ①package.json，②package-lock.json，③readme.md，④static，⑤src，⑥dist，⑦build，⑧config，⑨node_modules</li><li>依次说明各个文件以及文件夹的作用。<ul><li>①package.json。 该项目的包管理配置文件，由npm产生，用于npm下载所需要的依赖包以及项目的基本信息。该json配置的各项内容主要有：name（项目名称）、version（项目版本）、description（项目介绍）、author（作者）、private（是否私密项目），前面都是基础的信息，比较简单，在使用 <code>npm init</code> 的时候就产生了。 接着是比较重要的 script（脚本命令）：这是能在node下运行的js命令，例如 “dev”:”webpack-dev-server –inline –progress –config build/webpack.dev.conf.js” 这是webpack的一个插件”webpack-dev-server”提供的功能，”–config”后面跟着的js文件是其配置文件。 再如”eslint –ext .js,.vue src”,这是eslint模块提供的功能，后面的参数是指在src文件夹中用eslint检查 js文件和vue文件的语法。 最后的”node build/build.js”是执行的webpack的打包功能，之所以不是用 <code>webpack</code> 来执行，是由于在执行webpack之前，还行进了一系列的检查工作，而这部分内容直接写在 build.js 里的，其实webpack也是可以直接使用的，它有一些默认的配置。 再后面是 “dependencies”，这是指该项目在运行时需要的依赖包，在进行webpack打包的时候，打包的时候会将这些包直接打包进bundle.js文件里，常用的例如 “jquery””bootstrap””vue””vue-router””element”这些前段要直接使用的。 下一个内容是 devDependencies，这里面是我们在开发时需要的包，在我们使用<code>npm install</code>的时候，npm就会自动去下载这些依赖包，同样，这些依赖包本身可能也有一些依赖包，因此在下载时，npm也会将这些依赖包的依赖包一并下载了，于是，有时候虽然我们执行一个install xxx，最后却发现node_modules里面有很多的模块，常见的开发是依赖包例如，webpack用于打包，css-loader用于识别css文件，vue-loader用于识别vue文件，eslint用于进行es语法检查，babel用于进行兼容es6的一些特性。 然后是engines ，用于规定node和npm的版本。 最后还有一个 browserslist，这个是用来添加css兼容代码或者js兼容代码的，在can i use的规则下，自动智能地添加兼容代码（js垫片）。</li><li>②package-lock.json。 这个文件就是只在node_modules里面下载的所有依赖包，包括依赖包的来源、依赖包的依赖包等。我们在开发时一般用不上这个文件。</li><li>③README.md。 就是说明性文件。 初始包括我们的distribution，以及该项目的script命令。</li><li>④static。 这个文件夹的内容不会被webpack打包，一些不需要打包的文件可以放在这里面，例如一些图片、视频文件、供下载的文件等等。 在使用时直接引用/static就ok了。</li><li>⑤src。 这个文件夹可以说是最重要的文件夹了，因为我们自己写的各种内容都是在这个文件夹里放着的，也就是说我们开发的所有组件、页面、资源等，都放在这个文件中，所有内容都会被webpack打包。这个文件内又有一些其他的文件，稍后单独说明。</li><li>⑥dist。 这个文件夹存放的是webpack打包后的内容，有一个index.html文件，一个static文件夹，文件夹内为css、js、img等webpack自动生成的文件夹。我们网站运行后，主目录可以直接指向这个文件夹。</li><li>⑦build。 该文件夹存放webpack的配置文件或者相关的执行文件，主要的文件是build.js，同时，在这里也可以定义不同环境下打包的配置文件，例如有webpack.dev.conf.js或者webpack.prod.conf.js，分别用于打包生产环境下和开发环境下的文件。</li><li>⑧config。 这是一些配置文件，用于配置一些webpack-dev-server的参数，例如host、port、是否打开浏览器这类。<a href="https://www.cnblogs.com/caideyipi/p/8187656.html" target="_blank" rel="noopener">一篇解释的文章</a></li><li>⑨node_modules。 用于存放安装在本地的模块文件。</li></ul></li><li>鉴于当前对我来说，最重要的文件夹是src，因此说明一下src的文件夹下内容。src中有这些文件：①App.vue，②assets，③components，④main.js，⑤router。<ul><li>①App.vue。 这个文件为vue的主组件，默认内容为一个vue的图标。</li><li>②assets。 用于存放一些静态资源，例如图片。</li><li>③components。 用于存放vue的组件，我们自己写的模块代码片段就放在这里面。</li><li>④main.js。 vue执行时的入口文件，定义了一个vue对象（app）。与index.html中的<div id="app">相对应。<br>【应当先把vue官方文档通读之后再回来总结和复习】</div></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端知识学习思考（重要）</title>
    <link href="undefined2019/08/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>2019/08/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>虽然从比较早就开始在接触web前段的知识了（html、css、js、jquery、bootstrap、vue），甚至也接触了一些web后端的知识（php、java、mysql、cmd、linux、IIS等），但现在反观之前的学习成果，深感效率之底下，很多地方都没有认识清楚，认为非常有必要重新学习并整理知识框架。</li><li>按理说，有两个月的学习时间，加上这么多年以来的生活经验，应该是能够对部分技术有较深入的认识，至少能够做出一些东西，并能够总结出一些框架性的东西。但是就我当下能够拿得出手的，可能也只有模仿写了B站的几个静态页面了，可以说层次是非常低了，那么，为什么实际跟预想差了这么多呢？</li></ul><h2 id="最严重的问题之一：心志不坚定！"><a href="#最严重的问题之一：心志不坚定！" class="headerlink" title="最严重的问题之一：心志不坚定！"></a>最严重的问题之一：心志不坚定！</h2><ul><li>从开始接触web技术，态度就一直处于摇摆不定的状态，中间一直有各种不大不小的事情，总能让我找到一些看似很合理的借口，例如要写论文啊、要先把CPA的课看一看啊、要锻炼啊、要先搞好生活啊、最近状态不大好啊…… </li><li>其实说到底，就是心志还不坚定，还没有决定好自己要往哪个方向去发展，要做哪方面的事。一方面，由于自己在生活中遇到了几件不大好处理的事，被这些事压得神经紧张，整天处在压抑、纠结、懊恼、自卑的状态下。另一方面，自己在人际关系上遭受了很大的冲击，导致我在处理人际关系时习惯性选择躲避，内向、孤僻、毒舌逐渐成了我在社交上的主旋律。因此，个人的思绪很是混乱，生活没有主线，没能让自己静下心来去专研一件事。</li><li>虽然明明知道自己当下的情况很是糟糕，没有工作、没有技术、社交能力不足、生活作息紊乱、锻炼荒废……，但依然没有太大的心思去认真思考自己的未来。加上对未来生活比较悲观，对未来的工作形势也比较悲观，因此“享受当下”的心态逐渐冒头，喜欢花钱的感觉，虽然买的东西自己用到的频率会很低很低。在“未来精彩的人生”和“当下轻松地活着”这两种抉择下，竟渐渐有了妥协的心思。</li><li>这是从“正心”的环节就开始不在道上了。</li><li>在慢慢磨过了一些事情后，思维变得越来越麻木，很多事情之前觉得天大的事，现在也都成了“无所谓”了，可能是由于失去了很多，觉得再失去一点也就那样，也不在乎会对我产生多大的影响，我现在哪里还在乎得了那么多……</li><li>于是，我开始逐渐关注起自己感兴趣的事，开始放下功利的心态去看待学习，放下逃避的心态去看动漫，放下自卑的心理去看待感情，神奇的是，我居然看到了自己真心感兴趣的方向，感受到了学习对于我生活的意义，感受到了动漫人物演绎出的那些情感，也逐渐认识到感情对于我生活的意义。</li><li>每个人都有方方面面的问题，我甚至觉得自己问题更多，但我们依然要悦纳自己，在这个终生皆苦逼的世界，做一个爱自己的人，在有生之年，遍尝人间百味，就算时运不济失去一切，也能在最后的时间里不悔这一生的所作所为。</li><li>这种事情也不是能够一蹴而就的，不要强求一小段时间内就一定要找到些什么，保持好奇心，去感受编程带给我的快乐，感受生活带给我的不同体验。</li></ul><h2 id="严重的问题之二：计划不明确！"><a href="#严重的问题之二：计划不明确！" class="headerlink" title="严重的问题之二：计划不明确！"></a>严重的问题之二：计划不明确！</h2><ul><li>从学习的效率角度来讲，计划应该是所有工作的第一步，一个明确的、可执行的、可度量的、有反馈的计划，绝对是学习的强力驱动器。</li><li>我之气的学习一直是非常随性的，每天的学习内容都没有计划，想看看什么就去看什么，也没有对学习的过程和结果做任何的控制，学习时的随意性非常大，也导致了就算是刚看完一个知识，转眼过来就记不得看过什么了。</li><li>因此计划一定是要有的，从比较宏观的学习内容的规划，到比较细节的每日todolist，都要做好，并按照规划的内容去执行，每日还要做一次以上的review，以此提高自己的学习效率。</li></ul><h2 id="严重的问题之三：总结不到位！"><a href="#严重的问题之三：总结不到位！" class="headerlink" title="严重的问题之三：总结不到位！"></a>严重的问题之三：总结不到位！</h2><ul><li>框架的重要性。用思维导图进行总结。</li></ul><h2 id="严重的问题之四：实践太少了！"><a href="#严重的问题之四：实践太少了！" class="headerlink" title="严重的问题之四：实践太少了！"></a>严重的问题之四：实践太少了！</h2><ul><li>编程是一门实践性的技术，没有实践就永远不知道自己会什么。</li></ul><h2 id="严重的问题之五：时间管理太混乱！"><a href="#严重的问题之五：时间管理太混乱！" class="headerlink" title="严重的问题之五：时间管理太混乱！"></a>严重的问题之五：时间管理太混乱！</h2><ul><li>生活、学习，都需要有稳定的作息做保证。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录js学习思考</title>
    <link href="undefined2019/07/31/js%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83/"/>
    <url>2019/07/31/js%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>从学习开始，最早接触的编程类语言就是javascript，虽说这是一门动态语言，相对一些非常严谨的编程语言来说（比如java），更容易接受和入门。同时，由于是从web前段开始接触到的js，因此开始接触时具有比较好的直观感受，因此，会让人觉得js非常简单。</li><li>但实际上，js的内容非常丰富，完全不止是写一些简单的控制跳转或者动作控制之类的那些内容。毕竟，js作为一门编程语言，是具有了一门编程语言所需要的几乎所有东西，尤其是其面向对象的编程方式，使得其可扩展性非常强，因此，关于“对象”的学习尤其重要。</li><li>由于之前对js的狭隘理解（理解成了简单的浏览器对象的操作），因此重视程度完全不足，加上学习方式还非常鄙陋，想到要做一个什么东西，然后就开始调试型写代码，错了就调，调对了为止，缺少从原理上思考其原因的过程，并且缺少必要的总结，所以脑海中对于js的整体框架非常模糊，认知水平仅仅是停留在了定义一些变量，然后做一些简单的运算，过程中的状态是：缺少什么就赶紧加个什么，然后接着调试型编程。 这是非常有问题的。</li><li>因此，从这之后要改变这种学习的方式，还是那句话，不能用体力上的重复劳动和无效劳动代替大脑的思考和创造。</li><li>不仅是对js的学习，其他方面的知识也一样，一定要有格局，能从比较宏观的层面看透这个知识体系，因此必须要总结，思路必须要清晰。</li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul><li>从现在开始（7.30早7点），全身心学习js，跟着完整的教程，做完善的学习计划，调整好自己学习的状态。</li><li>学习内容：</li><li>学习过程控制：<ul><li>每个小时进行学习内容回顾与记录。</li><li>开直播，公开自己的学习过程。</li><li>写学习笔记。</li><li>将过程资料开源。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录js学习过程</title>
    <link href="undefined2019/07/30/js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <url>2019/07/30/js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<h1 id="学习js的第一天"><a href="#学习js的第一天" class="headerlink" title="学习js的第一天"></a>学习js的第一天</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><ul><li><p>学习内容</p><ul><li>JS基础教程</li></ul></li><li><p>学习材料</p><ul><li><a href="https://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener">w3schooljs教程</a></li><li>截至到：<a href="https://www.w3school.com.cn/js/js_window.asp" target="_blank" rel="noopener">browser BOM</a></li><li>需要学习的材料：<a href="https://www.runoob.com/w3cnote_genre/es6" target="_blank" rel="noopener">菜鸟ES6</a></li><li>一定要学习的材料：<a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮一峰书籍</a></li></ul></li></ul><h2 id="知识记录"><a href="#知识记录" class="headerlink" title="知识记录"></a>知识记录</h2><ul><li>js跟我同龄的</li><li>console 对象<ul><li>该对象不是js内建的对象，而是由浏览器提供，因此不同的浏览器可能方法或属性不一样。</li><li>console的方法中，log()、info()、error()、warn()最常用，可以用于编写易于调试的js程序。</li><li>console的输出方法中，像c语言一样，使用占位符，%s 字符串，%d 整数，%f 浮点数，%c 占位内容为css，将内容渲染输出（可以输出一些有趣的图形啥的）。</li><li><code>console.group()/.groupend()</code> 用于分组输出，调试时可用。</li><li><code>console.assert()</code>断言，用于判断assert中的表达式是否为真。</li><li><code>console.trance()</code> 追踪，每次其所在函数被调用一次，就向控制台输出调用所在函数的函数。可用于追踪调用。</li></ul></li><li>js有5种基础数据类型，一种复杂数据类型。前者为：number、string、Boolean、undefined、null；后者为：object。（array 是object）</li><li>var定义变量时可以用逗号分隔。 逗号后可以跨行。</li><li>4+6+”8”==468  （注意这里跟其他语言的对比）</li><li>运算符类型： 数学运算（加减乘除余）、赋值运算(+= -= *=……)、字符串运算、比较运算、位运算、类型运算（typeof、instenceod）、逻辑运算</li><li><code>**</code>表示幂（es6）、 xx in xx的用法（es6）</li><li>this 指向当前函数的拥有者。 例如在函数中使用 this.name 指的是跟函数平级的name属性。</li><li>对象的创建方法2种： ①var xx = new object() 这被称为对象的构造函数、②var xx = {}.</li><li>对象的调用方法2种： ①英文点、②中括号加引号。</li><li>js事件： 鼠标事件（上、下、上下、进、出、动）、键盘事件（上、下、上下）、浏览器事件（加载、关闭）、窗口事件（获得焦点、失去焦点、变化大小）、输入框事件（获得焦点、失去焦点、change）、滚动条事件（滚动）。</li><li>字符串内换行：用反斜杠<code>\</code></li></ul><p><strong>字符串</strong><br>    * 属性：①string.length<br>    * 方法：<br>        - <code>string.indexOf(&quot;&quot;)\lastIndexOf()</code>（没找到就返回-1），search()可以用正则？<br>        - 切割：slice(2,6)3-6的字符，silce(7)第7个字符后的字符，slice(-7)倒数第七个后的字符。substr(3,4)，从第4个开始，切4个字符。<br>        - <code>replace(&quot;&quot;,&quot;&quot;)</code>，用后面替换前面，默认只替换第一个，可以使用正则，不改变原字符串，想改变要用 str = str.replace()。<br>        - <code>.toUpperCase()/.toLowerCase()</code>改变大小写。 <code>.concat()/+</code> 连接字符串<br>        - <code>.trim()</code>删除空格，不改变原字符<br>        - <code>.charAt()</code> 指定下标的字符。（用<code>slice(n,n+1)</code>或者<code>substr(n,1)</code>也可以实现）<br>        - 字符串可以直接用 <code>str[n]</code>访问第n个字符，看起来像数组访问一样。<br>        - <code>.charCodeAt()</code> 该字符的unicode值<br>        - <code>.split(&quot;X&quot;)</code> 用X分割字符串成为一个数组<br>        - <code>.toString()</code> 转变成字符串</p><p><strong>数字</strong><br>    * 方法：<br>        - <code>.toFixed(6)</code> 返回6位小数的字符串<br>        - <code>.toPrecious(4)</code> 返回共4个位的字符串<br>        - <code>.valueOf()</code>和<code>.toString()</code>是一个等级的<br>        - <code>.parseInt()</code>、<code>.parseFloat()</code>转换可识别的数字</p><p><strong>数组</strong><br>    * 创建： <code>var xx = [] 、 var xx = new Array()</code><br>    * 读取： <code>xx[n]</code><br>    * 方法：<br>        - <code>arr.foreach(fun (value, index, array){})</code> 遍历()<br>        - 增减：<code>push()、pop()、shift()、unshift()、xx[xx.length]=&quot;&quot;</code><br>        - 检测： <code>isArray()</code><br>        - join(“*”) 可用<code>*</code>来连接数组各个值<br>        - delete()会产生undefined<br>        - 用splice()来删除或者添加数组的新项，<code>.splice(3,1,&quot;xx1&quot;,&quot;xx2&quot;)</code>，3为开始位置(会直接删除)，1位删除的数量，后面的是要添加的。<br>        - concat()，拼接数组。<br>        - slice()，用于返回切出了一部分后的新数组，slice(3,1)，从3后面开始1个<br>        - sort()，按字母顺序排列。 reverse()，按字母反顺序排列。<br>        - sort(fun(pre,next){return pre-next})，可以进行比值，按数字顺序排列<br>        - 数组的最大最小值，用Math对象，Math.max.apply(arr)<br>        - <code>.map(fun(value, index, array){})</code>，对数组中的每个值进行一次处理，并return一个值。<br>        - .filter() return 用true和false控制是否过滤<br>        - .every() .some() 用于判断部分是否通过条件<br>        - .find() 用于查找符合条件的第一个元素的值<br>        - .indexOf() .lastIndexOf() 类似于字符串的方法。</p><p><strong>日期对象</strong><br>    * 创建：var xx = new Date(); var xx = new Date(“”,””,””)<br>    * 变成字符串： xx.toDateString()。<br>    * 获得时间： D.getFullYear() 、D.getMonth()、D.getDay()、D.getHours()、D.getMinutes……<br>    * 设置时间： D.set…… （同上）</p><p><strong>js加速</strong><br>    * 在循环中少使用对象查询，而是用变量直接代替。<br>    * 尽量减少对dom的不必要获取。<br>    * 减少对不必要中间变量的使用。<br>    * script加载放到页尾。</p><p><strong>json对象</strong><br>    * 方法：<br>        - json.parse()解析json<br>        - json.stringify()转换成文本</p><p><strong>其他</strong><br>    * getter和setter： 主要能够使对象的方法和属性使用同样的语法。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是WSDL？</title>
    <link href="undefined2019/07/30/%E4%BB%80%E4%B9%88%E6%98%AFWSDL/"/>
    <url>2019/07/30/%E4%BB%80%E4%B9%88%E6%98%AFWSDL/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是WSDL"><a href="#什么是WSDL" class="headerlink" title="什么是WSDL"></a>什么是WSDL</h2><ul><li>web service describe language，是一种用于请求web服务的标准，用xml进行描述， 可以让程序请求web服务</li><li>curl和wsdl是什么关系？</li><li>SOAP 同样是一种用xml的web service标准，可用于向服务器发送相关信息，进行数据请求，可以选择不同的协议。 SOAP是一种协议，用于规定web service需要的参数以及其格式，这个协议还可以规定发送web service请求的协议，例如http协议，而WSDL是一种语言，这种语言可以实现webservice的功能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于博客的规划</title>
    <link href="undefined2019/07/29/%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E8%A7%84%E5%88%92/"/>
    <url>2019/07/29/%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="对于博客的规划"><a href="#对于博客的规划" class="headerlink" title="对于博客的规划"></a>对于博客的规划</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>基本上所有的大牛都会建议初学者养成写博客的习惯，虽然我也一直告诉自己要养成这样的好习惯，陆陆续续也在往这条路上走，但整体来说，养成习惯的速度有点慢，写博客的感觉还是时有时无。</li><li>这可以从侧面说明我在框架性思考一些知识的时候还是有所欠缺，才在一定层面导致没有写博客的感觉，另一层面，我写博客还经常会存在被其他事物干扰的情况，说明我在写博客时的沉浸式状态还没有完全成型。</li><li>上述两方面都是我在后续的码字过程中需要提升的，达到码字流畅，思路清晰，习惯良好，才能在写博客的时候感受到更多的乐趣。 这样，写代码这件事带给我的乐趣就又多了一项。</li></ul><h2 id="博客可以用来做啥"><a href="#博客可以用来做啥" class="headerlink" title="博客可以用来做啥"></a>博客可以用来做啥</h2><ul><li>两个方面的作用，其一，用于整理自己的思路，记录当下解决问题的思路和方法，便于加深对一个事物的认识，或者留作将来的参考；其二，用于交流，把自己的思考总结出来，可以供大家参考和评论，在讨论中提升对事物的更深认识。</li></ul><h2 id="博客要怎么写"><a href="#博客要怎么写" class="headerlink" title="博客要怎么写"></a>博客要怎么写</h2><ul><li>先从博客的平台上来说，有两个，一个是CSDN的博客，另一个就是自己的博客站。 现阶段自己的博客数量还不够丰富，因此先在CSDN上发布，然后搭建好自己的博客平台，将来保持在两个平台上均有发布。</li><li>从功能上来讲，CSDN应当更多发布教程类博客，用于记录一些操作步骤，或者专门写一部分的入门教程之类的，CSDN主要是用来给大家看的，同时用于存档一些疑难问题，便于自己将来操作时参考。</li><li>而自己的博客站，主要是自己玩的一些东西，用于发表一些感想、程序生涯中的一些趣事、自己做的一些好玩的项目。</li></ul><h2 id="博客站的搭建"><a href="#博客站的搭建" class="headerlink" title="博客站的搭建"></a>博客站的搭建</h2><ul><li><p>博客站应当遵循响应式的站点，可以适配PC和移动端。</p></li><li><p>整体风格偏向深色简约风，类似于当前sublime的风格，具体搭配如下：</p><ul><li>背景颜色:#224450 正文颜色:#C0C0C0 标题颜色:#FFFFFF 标题hover颜色:#DDDDDD btn颜色:#FAFAFA line hover颜色:#4D5A64 tag框颜色：#DDDDDD tag文本颜色：#FFFFFF </li><li>正文大小：1rem 标题：2rem 副标题：1.5rem 时间：.7rem 一级head：1.5rem 二级head：1.3rem 三级head：1.1rem bold</li></ul></li><li><p>页面分为五个部分：</p><ul><li>主页： 一个超级简单的show</li><li>分类页： 分为首页、分类页、tag页</li><li>详细页： 文章详情</li><li>时间线： 文章发表的时间线罗列</li><li>aboutme： 简单的自我介绍叭</li></ul></li><li><p>框架：</p><ul><li>顶部导航栏</li><li>头部图片展示栏</li><li>底部备案与版权</li></ul></li><li><p>组件：</p><ul><li>左边菜单栏拉出</li><li>右边文章结构图</li><li>右下角回到顶部</li><li>右下角评论弹出</li></ul></li></ul><h2 id="关于技术使用"><a href="#关于技术使用" class="headerlink" title="关于技术使用"></a>关于技术使用</h2><ul><li>在目前对后端技术非常不熟的情况下，贸然写后端的内容，将会让编程的快乐离我们很远，这不是一件好的事情，因此，暂时先不写后端的内容，而是按照对后端的内容提供的需求进行接口方面的文档编写。</li><li>虽然不直接实现后端，但后端的规划是要有的，由于对后端的认识还非常不到位，因此应当从基础的入手，采用PHP+mySQL+Appache的组合（WMAP框架），前后端分离式的发开，后台仅负责数据的传输，以及少部分业务逻辑的处理。</li><li>前端采用响应式开发，由于这个博客网站相对来说前端比较简单，因此不使用UI框架，以保证整个页面的代码简练。 在js动作控制方面，采用jQuery，这个似乎还是避不开啊，不然用原生JS的话，写起来似乎有点痛苦啊。另外，采用vue的前端开发框架，用前端路由以及ajax做单页应用，用来保证页面跳转的流畅性。</li><li>博客这个项目确实非常适合单页应用，虽然可以不用vue，采用页面标签等方一法样可以实现，但为了适应将来的模块化开发和工程化开发，应当要不断熟练vue的用法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>规划</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>